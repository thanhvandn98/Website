<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.42.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : Proc  -   Ruby 2.7.1 ' />
  <meta content="2020-04-01 15:56:53 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = false-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: Proc (Ruby 2.7.1) </title>
  <link rel="stylesheet" href="css/associated.css" type="text/css" >
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >
    <link rel="stylesheet" href="css/carbon17.css" type="text/css" >


  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 


   
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

   <link rel="stylesheet" href="css/extra.css" type="text/css" >
  <script  src="/js/extra.js"  ></script>


</head>

<body id="top" class="class rdocstar">

<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 2.7.1 NOT FOUND -->
</div> <!-- end action bar -->
 <div class='wrapper'>
  
   <!-- carbon17 added here 2017-09-09 -->
 

   <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>proc.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-3C-3C">#<<</a></li>
          
          <li><a href="#method-i-3D-3D-3D">#===</a></li>
          
          <li><a href="#method-i-3E-3E">#>></a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-arity">#arity</a></li>
          
          <li><a href="#method-i-binding">#binding</a></li>
          
          <li><a href="#method-i-call">#call</a></li>
          
          <li><a href="#method-i-curry">#curry</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-lambda-3F">#lambda?</a></li>
          
          <li><a href="#method-i-parameters">#parameters</a></li>
          
          <li><a href="#method-i-ruby2_keywords">#ruby2_keywords</a></li>
          
          <li><a href="#method-i-source_location">#source_location</a></li>
          
          <li><a href="#method-i-to_proc">#to_proc</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-yield">#yield</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id='files'>
        
          
          <li class="file"><a href="./_lib/racc/rdoc/grammar_en_rdoc.html">grammar.en.rdoc</a></li>
        
          
          <li class="file"><a href="./_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./COPYING_ja.html">COPYING.ja</a></li>
        
          
          <li class="file"><a href="./README_EXT.html">README.EXT</a></li>
        
          
          <li class="file"><a href="./README_EXT_ja.html">README.EXT.ja</a></li>
        
          
          <li class="file"><a href="./configure_ac.html">configure.ac</a></li>
        
          
          <li class="file"><a href="./doc/bug_triaging_rdoc.html">bug_triaging.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributors_rdoc.html">contributors.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/extension_ja_rdoc.html">extension.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/extension_rdoc.html">extension.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/signals_rdoc.html">signals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/comments_rdoc.html">comments.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="./lex_c_blt.html">lex.c.blt</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./ARGF.html">ARGF</a></li>
        
          
          
          <li><a href="./ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="./Array.html">Array</a></li>
        
          
          
          <li><a href="./BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="./Binding.html">Binding</a></li>
        
          
          
          <li><a href="./Class.html">Class</a></li>
        
          
          
          <li><a href="./ClosedQueueError.html">ClosedQueueError</a></li>
        
          
          
          <li><a href="./Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="./Complex.html">Complex</a></li>
        
          
          
          <li><a href="./ConditionVariable.html">ConditionVariable</a></li>
        
          
          
          <li><a href="./Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="./Data.html">Data</a></li>
        
          
          
          <li><a href="./Dir.html">Dir</a></li>
        
          
          
          <li><a href="./ENV.html">ENV</a></li>
        
          
          
          <li><a href="./EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="./Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="./Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="./Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="./Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="./Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="./Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="./EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="./Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="./Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="./Enumerator/ArithmeticSequence.html">Enumerator::ArithmeticSequence</a></li>
        
          
          
          <li><a href="./Enumerator/Chain.html">Enumerator::Chain</a></li>
        
          
          
          <li><a href="./Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="./Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="./Enumerator/Producer.html">Enumerator::Producer</a></li>
        
          
          
          <li><a href="./Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="./Errno.html">Errno</a></li>
        
          
          
          <li><a href="./Exception.html">Exception</a></li>
        
          
          
          <li><a href="./FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="./Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="./FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="./File.html">File</a></li>
        
          
          
          <li><a href="./File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="./File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="./FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="./FrozenError.html">FrozenError</a></li>
        
          
          
          <li><a href="./GC.html">GC</a></li>
        
          
          
          <li><a href="./GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="./Hash.html">Hash</a></li>
        
          
          
          <li><a href="./IO.html">IO</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="./IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="./IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="./IOError.html">IOError</a></li>
        
          
          
          <li><a href="./IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="./LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="./LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="./Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="./MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="./Math.html">Math</a></li>
        
          
          
          <li><a href="./Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="./Method.html">Method</a></li>
        
          
          
          <li><a href="./Module.html">Module</a></li>
        
          
          
          <li><a href="./Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="./NameError.html">NameError</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./NoMatchingPatternError.html">NoMatchingPatternError</a></li>
        
          
          
          <li><a href="./NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="./NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="./NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="./Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="./Object.html">Object</a></li>
        
          
          
          <li><a href="./ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="./ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="./Pool.html">Pool</a></li>
        
          
          
          <li><a href="./Proc.html">Proc</a></li>
        
          
          
          <li><a href="./Process.html">Process</a></li>
        
          
          
          <li><a href="./Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="./Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="./Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="./Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="./Queue.html">Queue</a></li>
        
          
          
          <li><a href="./Random.html">Random</a></li>
        
          
          
          <li><a href="./Random/Formatter.html">Random::Formatter</a></li>
        
          
          
          <li><a href="./Range.html">Range</a></li>
        
          
          
          <li><a href="./RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="./Rational.html">Rational</a></li>
        
          
          
          <li><a href="./Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="./RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="./Ripper.html">Ripper</a></li>
        
          
          
          <li><a href="./RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="./RubyVM/AbstractSyntaxTree.html">RubyVM::AbstractSyntaxTree</a></li>
        
          
          
          <li><a href="./RubyVM/AbstractSyntaxTree/Node.html">RubyVM::AbstractSyntaxTree::Node</a></li>
        
          
          
          <li><a href="./RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="./RubyVM/MJIT.html">RubyVM::MJIT</a></li>
        
          
          
          <li><a href="./RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="./ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="./SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="./Signal.html">Signal</a></li>
        
          
          
          <li><a href="./SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="./SizedQueue.html">SizedQueue</a></li>
        
          
          
          <li><a href="./StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="./StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
          
          
          <li><a href="./Struct.html">Struct</a></li>
        
          
          
          <li><a href="./Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="./SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="./SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="./SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="./SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="./Thread.html">Thread</a></li>
        
          
          
          <li><a href="./Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="./ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="./ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
          
          
          <li><a href="./TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="./TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="./TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="./UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="./UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="./UnicodeNormalize.html">UnicodeNormalize</a></li>
        
          
          
          <li><a href="./Warning.html">Warning</a></li>
        
          
          
          <li><a href="./ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="./fatal.html">fatal</a></li>
        
          
          
          <li><a href="./unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">Proc</h1>

    <div id="description" class="description">
      
<p>A <code>Proc</code> object is an encapsulation of a block of code, which
can be stored in a local variable, passed to a method or another <a
href="Proc.html">Proc</a>, and can be called. <a href="Proc.html">Proc</a>
is an essential concept in Ruby and a core of its functional programming
features.</p>

<pre class="ruby"><span class="ruby-identifier">square</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }

<span class="ruby-identifier">square</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">3</span>)  <span class="ruby-comment">#=&gt; 9</span>
<span class="ruby-comment"># shorthands:</span>
<span class="ruby-identifier">square</span>.(<span class="ruby-value">3</span>)      <span class="ruby-comment">#=&gt; 9</span>
<span class="ruby-identifier">square</span>[<span class="ruby-value">3</span>]       <span class="ruby-comment">#=&gt; 9</span>
</pre>

<p><a href="Proc.html">Proc</a> objects are <em>closures</em>, meaning they
remember and can use the entire context in which they were created.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">gen_times</span>(<span class="ruby-identifier">factor</span>)
  <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">n</span><span class="ruby-operator">*</span><span class="ruby-identifier">factor</span> } <span class="ruby-comment"># remembers the value of factor at the moment of creation</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">times3</span> = <span class="ruby-identifier">gen_times</span>(<span class="ruby-value">3</span>)
<span class="ruby-identifier">times5</span> = <span class="ruby-identifier">gen_times</span>(<span class="ruby-value">5</span>)

<span class="ruby-identifier">times3</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">12</span>)               <span class="ruby-comment">#=&gt; 36</span>
<span class="ruby-identifier">times5</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">5</span>)                <span class="ruby-comment">#=&gt; 25</span>
<span class="ruby-identifier">times3</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">times5</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">4</span>))   <span class="ruby-comment">#=&gt; 60</span>
</pre>

<h2 id="class-Proc-label-Creation">Creation<span><a href="#class-Proc-label-Creation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>There are several methods to create a <a href="Proc.html">Proc</a></p>
<ul><li>
<p>Use the <a href="Proc.html">Proc</a> class constructor:</p>

<pre class="ruby"><span class="ruby-identifier">proc1</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }
</pre>
</li><li>
<p>Use the <a href="Kernel.html#method-i-proc">Kernel#proc</a> method as a
shorthand of <a href="Proc.html#method-c-new">::new</a>:</p>

<pre class="ruby"><span class="ruby-identifier">proc2</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }
</pre>
</li><li>
<p>Receiving a block of code into proc argument (note the <code>&amp;</code>):</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">make_proc</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">proc3</span> = <span class="ruby-identifier">make_proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }
</pre>
</li><li>
<p>Construct a proc with lambda semantics using the <a
href="Kernel.html#method-i-lambda">Kernel#lambda</a> method (see below for
explanations about lambdas):</p>

<pre class="ruby"><span class="ruby-identifier">lambda1</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }
</pre>
</li><li>
<p>Use the Lambda literal syntax (also constructs a proc with lambda
semantics):</p>

<pre class="ruby"><span class="ruby-identifier">lambda2</span> = <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">x</span>) { <span class="ruby-identifier">x</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }
</pre>
</li></ul>

<h2 id="class-Proc-label-Lambda+and+non-lambda+semantics">Lambda and non-lambda semantics<span><a href="#class-Proc-label-Lambda+and+non-lambda+semantics">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Procs are coming in two flavors: lambda and non-lambda (regular procs).
Differences are:</p>
<ul><li>
<p>In lambdas, <code>return</code> and <code>break</code> means exit from this
lambda;</p>
</li><li>
<p>In non-lambda procs, <code>return</code> means exit from embracing method
(and will throw <code>LocalJumpError</code> if invoked outside the method);</p>
</li><li>
<p>In non-lambda procs, <code>break</code> means exit from the method which
the block given for. (and will throw <code>LocalJumpError</code> if invoked
after the method returns);</p>
</li><li>
<p>In lambdas, arguments are treated in the same way as in methods: strict,
with <code>ArgumentError</code> for mismatching argument number, and no
additional argument processing;</p>
</li><li>
<p>Regular procs accept arguments more generously: missing arguments are
filled with <code>nil</code>, single <a href="Array.html">Array</a>
arguments are deconstructed if the proc has multiple arguments, and there
is no error raised on extra arguments.</p>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># +return+ in non-lambda proc, +b+, exits +m2+.</span>
<span class="ruby-comment"># (The block +{ return }+ is given for +m1+ and embraced by +m2+.)</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">return</span> }; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; []</span>

<span class="ruby-comment"># +break+ in non-lambda proc, +b+, exits +m1+.</span>
<span class="ruby-comment"># (The block +{ break }+ is given for +m1+ and embraced by +m2+.)</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">break</span> }; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; [:m2]</span>

<span class="ruby-comment"># +next+ in non-lambda proc, +b+, exits the block.</span>
<span class="ruby-comment"># (The block +{ next }+ is given for +m1+ and embraced by +m2+.)</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">next</span> }; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; [:m1, :m2]</span>

<span class="ruby-comment"># Using +proc+ method changes the behavior as follows because</span>
<span class="ruby-comment"># The block is given for +proc+ method and embraced by +m2+.</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> { <span class="ruby-keyword">return</span> }); <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; []</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> { <span class="ruby-keyword">break</span> }); <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment"># break from proc-closure (LocalJumpError)</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> { <span class="ruby-keyword">next</span> }); <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; [:m1, :m2]</span>

<span class="ruby-comment"># +return+, +break+ and +next+ in the stubby lambda exits the block.</span>
<span class="ruby-comment"># (+lambda+ method behaves same.)</span>
<span class="ruby-comment"># (The block is given for stubby lambda syntax and embraced by +m2+.)</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-keyword">return</span> }); <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; [:m1, :m2]</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-keyword">break</span> }); <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; [:m1, :m2]</span>
<span class="ruby-identifier">$a</span> = []; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span>; <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m1</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>() <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-keyword">next</span> }); <span class="ruby-identifier">$a</span> <span class="ruby-operator">&lt;&lt;</span> :<span class="ruby-identifier">m2</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>; <span class="ruby-identifier">p</span> <span class="ruby-identifier">$a</span>
<span class="ruby-comment">#=&gt; [:m1, :m2]</span>

<span class="ruby-identifier">p</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;x=#{x}, y=#{y}&quot;</span> }
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>)      <span class="ruby-comment">#=&gt; &quot;x=1, y=2&quot;</span>
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">call</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>])    <span class="ruby-comment">#=&gt; &quot;x=1, y=2&quot;, array deconstructed</span>
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">8</span>)   <span class="ruby-comment">#=&gt; &quot;x=1, y=2&quot;, extra argument discarded</span>
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)         <span class="ruby-comment">#=&gt; &quot;x=1, y=&quot;, nil substituted instead of error</span>

<span class="ruby-identifier">l</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;x=#{x}, y=#{y}&quot;</span> }
<span class="ruby-identifier">l</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>)      <span class="ruby-comment">#=&gt; &quot;x=1, y=2&quot;</span>
<span class="ruby-identifier">l</span>.<span class="ruby-identifier">call</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>])    <span class="ruby-comment"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>
<span class="ruby-identifier">l</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">8</span>)   <span class="ruby-comment"># ArgumentError: wrong number of arguments (given 3, expected 2)</span>
<span class="ruby-identifier">l</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)         <span class="ruby-comment"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">test_return</span>
  <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> { <span class="ruby-keyword">return</span> <span class="ruby-value">3</span> }.<span class="ruby-identifier">call</span>      <span class="ruby-comment"># just returns from lambda into method body</span>
  <span class="ruby-identifier">proc</span> { <span class="ruby-keyword">return</span> <span class="ruby-value">4</span> }.<span class="ruby-identifier">call</span>    <span class="ruby-comment"># returns from method</span>
  <span class="ruby-keyword">return</span> <span class="ruby-value">5</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">test_return</span> <span class="ruby-comment"># =&gt; 4, return from proc</span>
</pre>

<p>Lambdas are useful as self-sufficient functions, in particular useful as
arguments to higher-order functions, behaving exactly like Ruby methods.</p>

<p>Procs are useful for implementing iterators:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">test</span>
  [[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>], [<span class="ruby-value">5</span>, <span class="ruby-value">6</span>]].<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-keyword">return</span> <span class="ruby-identifier">a</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">a</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">b</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">10</span> }
                            <span class="ruby-comment">#  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Inside <code>map</code>, the block of code is treated as a regular
(non-lambda) proc, which means that the internal arrays will be
deconstructed to pairs of arguments, and <code>return</code> will exit from
the method <code>test</code>. That would not be possible with a stricter
lambda.</p>

<p>You can tell a lambda from a regular proc by using the <a
href="Proc.html#method-i-lambda-3F">lambda?</a> instance method.</p>

<p>Lambda semantics is typically preserved during the proc lifetime, including
<code>&amp;</code>-deconstruction to a block of code:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> }
<span class="ruby-identifier">l</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> }
[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">p</span>) <span class="ruby-comment">#=&gt; [1, 2]</span>
[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]].<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">l</span>) <span class="ruby-comment"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>
</pre>

<p>The only exception is dynamic method definition: even if defined by passing
a non-lambda proc, methods still have normal semantics of argument
checking.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-identifier">define_method</span>(:<span class="ruby-identifier">e</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> {})
<span class="ruby-keyword">end</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">e</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)       <span class="ruby-comment">#=&gt; ArgumentError</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">method</span>(:<span class="ruby-identifier">e</span>).<span class="ruby-identifier">to_proc</span>.<span class="ruby-identifier">lambda?</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>This exception ensures that methods never have unusual argument passing
conventions, and makes it easy to have wrappers defining methods that
behave as usual.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">def2</span>(<span class="ruby-identifier">name</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">body</span>)
    <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">name</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">body</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">def2</span>(:<span class="ruby-identifier">f</span>) {}
<span class="ruby-keyword">end</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">f</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)       <span class="ruby-comment">#=&gt; ArgumentError</span>
</pre>

<p>The wrapper <code>def2</code> receives <em>body</em> as a non-lambda proc,
yet defines a method which has normal semantics.</p>

<h2 id="class-Proc-label-Conversion+of+other+objects+to+procs">Conversion of other objects to procs<span><a href="#class-Proc-label-Conversion+of+other+objects+to+procs">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Any object that implements the <code>to_proc</code> method can be converted
into a proc by the <code>&amp;</code> operator, and therefore con be
consumed by iterators.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Greeter</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">greeting</span>)
    <span class="ruby-ivar">@greeting</span> = <span class="ruby-identifier">greeting</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier">to_proc</span>
    <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;#{@greeting}, #{name}!&quot;</span> }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">hi</span> = <span class="ruby-constant">Greeter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Hi&quot;</span>)
<span class="ruby-identifier">hey</span> = <span class="ruby-constant">Greeter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;Hey&quot;</span>)
[<span class="ruby-string">&quot;Bob&quot;</span>, <span class="ruby-string">&quot;Jane&quot;</span>].<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">hi</span>)    <span class="ruby-comment">#=&gt; [&quot;Hi, Bob!&quot;, &quot;Hi, Jane!&quot;]</span>
[<span class="ruby-string">&quot;Bob&quot;</span>, <span class="ruby-string">&quot;Jane&quot;</span>].<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">hey</span>)   <span class="ruby-comment">#=&gt; [&quot;Hey, Bob!&quot;, &quot;Hey, Jane!&quot;]</span>
</pre>

<p>Of the Ruby core classes, this method is implemented by <a
href="Symbol.html">Symbol</a>, <a href="Method.html">Method</a>, and <a
href="Hash.html">Hash</a>.</p>

<pre class="ruby">:<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">to_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)           <span class="ruby-comment">#=&gt; &quot;1&quot;</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span>:<span class="ruby-identifier">to_s</span>)              <span class="ruby-comment">#=&gt; [&quot;1&quot;, &quot;2&quot;]</span>

<span class="ruby-identifier">method</span>(:<span class="ruby-identifier">puts</span>).<span class="ruby-identifier">to_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment"># prints 1</span>
[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>].<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">method</span>(:<span class="ruby-identifier">puts</span>))     <span class="ruby-comment"># prints 1, 2</span>

{<span class="ruby-identifier">test</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">to_proc</span>.<span class="ruby-identifier">call</span>(:<span class="ruby-identifier">test</span>)       <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-operator">%</span>[<span class="ruby-identifier">test</span> <span class="ruby-identifier">many</span> <span class="ruby-identifier">keys</span>].<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span>{<span class="ruby-identifier">test</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>})  <span class="ruby-comment">#=&gt; [1, nil, nil]</span>
</pre>

<h2 id="class-Proc-label-Orphaned+Proc">Orphaned <a href="Proc.html">Proc</a><span><a href="#class-Proc-label-Orphaned+Proc">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><code>return</code> and <code>break</code> in a block exit a method. If a
<a href="Proc.html">Proc</a> object is generated from the block and the <a
href="Proc.html">Proc</a> object survives until the method is returned,
<code>return</code> and <code>break</code> cannot work. In such case,
<code>return</code> and <code>break</code> raises <a
href="LocalJumpError.html">LocalJumpError</a>. A <a
href="Proc.html">Proc</a> object in such situation is called as orphaned <a
href="Proc.html">Proc</a> object.</p>

<p>Note that the method to exit is different for <code>return</code> and
<code>break</code>. There is a situation that orphaned for
<code>break</code> but not orphaned for <code>return</code>.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>(); <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">return</span> } <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span> <span class="ruby-comment"># ok</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">call</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>(); <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">break</span> } <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span> <span class="ruby-comment"># ok</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>(); <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">return</span> }.<span class="ruby-identifier">call</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span> <span class="ruby-comment"># ok</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>(); <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">break</span> }.<span class="ruby-identifier">call</span> <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span> <span class="ruby-comment"># LocalJumpError</span>

<span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>(); <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">return</span> } <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>.<span class="ruby-identifier">call</span> <span class="ruby-comment"># LocalJumpError</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">m1</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">def</span> <span class="ruby-identifier">m2</span>(); <span class="ruby-identifier">m1</span> { <span class="ruby-keyword">break</span> } <span class="ruby-keyword">end</span>; <span class="ruby-identifier">m2</span>.<span class="ruby-identifier">call</span> <span class="ruby-comment"># LocalJumpError</span>
</pre>

<p>Since <code>return</code> and <code>break</code> exits the block itself in
lambdas, lambdas cannot be orphaned.</p>

<h2 id="class-Proc-label-Numbered+parameters">Numbered parameters<span><a href="#class-Proc-label-Numbered+parameters">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Numbered parameters are implicitly defined block parameters intended to
simplify writing short blocks:</p>

<pre class="ruby"><span class="ruby-comment"># Explicit parameter:</span>
<span class="ruby-node">%w[test me please]</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">str</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">upcase</span> } <span class="ruby-comment"># prints TEST, ME, PLEASE</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>).<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; [1, 4, 9, 16, 25]</span>

<span class="ruby-comment"># Implicit parameter:</span>
<span class="ruby-node">%w[test me please]</span>.<span class="ruby-identifier">each</span> { <span class="ruby-identifier">puts</span> <span class="ruby-identifier">_1</span>.<span class="ruby-identifier">upcase</span> } <span class="ruby-comment"># prints TEST, ME, PLEASE</span>
(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>).<span class="ruby-identifier">map</span> { <span class="ruby-identifier">_1</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; [1, 4, 9, 16, 25]</span>
</pre>

<p>Parameter names from <code>_1</code> to <code>_9</code> are supported:</p>

<pre class="ruby">[<span class="ruby-value">10</span>, <span class="ruby-value">20</span>, <span class="ruby-value">30</span>].<span class="ruby-identifier">zip</span>([<span class="ruby-value">40</span>, <span class="ruby-value">50</span>, <span class="ruby-value">60</span>], [<span class="ruby-value">70</span>, <span class="ruby-value">80</span>, <span class="ruby-value">90</span>]).<span class="ruby-identifier">map</span> { <span class="ruby-identifier">_1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">_2</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">_3</span> }
<span class="ruby-comment"># =&gt; [120, 150, 180]</span>
</pre>

<p>Though, it is advised to resort to them wisely, probably limiting yourself
to <code>_1</code> and <code>_2</code>, and to one-line blocks.</p>

<p>Numbered parameters can&#39;t be used together with explicitly named ones:</p>

<pre class="ruby">[<span class="ruby-value">10</span>, <span class="ruby-value">20</span>, <span class="ruby-value">30</span>].<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">_1</span><span class="ruby-operator">**</span><span class="ruby-value">2</span> }
<span class="ruby-comment"># SyntaxError (ordinary parameter is defined)</span>
</pre>

<p>To avoid conflicts, naming local variables or method arguments
<code>_1</code>, <code>_2</code> and so on, causes a warning.</p>

<pre class="ruby"><span class="ruby-identifier">_1</span> = <span class="ruby-string">&#39;test&#39;</span>
<span class="ruby-comment"># warning: `_1&#39; is reserved as numbered parameter</span>
</pre>

<p>Using implicit numbered parameters affects block&#39;s arity:</p>

<pre class="ruby"><span class="ruby-identifier">p</span> = <span class="ruby-identifier">proc</span> { <span class="ruby-identifier">_1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">_2</span> }
<span class="ruby-identifier">l</span> = <span class="ruby-identifier">lambda</span> { <span class="ruby-identifier">_1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">_2</span> }
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">parameters</span>     <span class="ruby-comment"># =&gt; [[:opt, :_1], [:opt, :_2]]</span>
<span class="ruby-identifier">p</span>.<span class="ruby-identifier">arity</span>          <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">l</span>.<span class="ruby-identifier">parameters</span>     <span class="ruby-comment"># =&gt; [[:req, :_1], [:req, :_2]]</span>
<span class="ruby-identifier">l</span>.<span class="ruby-identifier">arity</span>          <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>Blocks with numbered parameters can&#39;t be nested:</p>

<pre class="ruby"><span class="ruby-node">%w[test me]</span>.<span class="ruby-identifier">each</span> { <span class="ruby-identifier">_1</span>.<span class="ruby-identifier">each_char</span> { <span class="ruby-identifier">p</span> <span class="ruby-identifier">_1</span> } }
<span class="ruby-comment"># SyntaxError (numbered parameter is already used in outer block here)</span>
<span class="ruby-comment"># %w[test me].each { _1.each_char { p _1 } }</span>
<span class="ruby-comment">#                    ^~</span>
</pre>

<p>Numbered parameters were introduced in Ruby 2.7.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new {|...| block } &rarr; a_proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new                &rarr; a_proc</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Proc.html">Proc</a> object, bound to the current
context. <a href="Proc.html#method-c-new">::new</a> may be called without a
block only within a method with an attached block, in which case that block
is converted to the <a href="Proc.html">Proc</a> object.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">proc_from</span>
  <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">proc</span> = <span class="ruby-identifier">proc_from</span> { <span class="ruby-string">&quot;hello&quot;</span> }
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">call</span>   <span class="ruby-comment">#=&gt; &quot;hello&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_proc_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE block = proc_new(klass, FALSE, FALSE);

    rb_obj_call_init_kw(block, argc, argv, RB_PASS_CALLED_KEYWORDS);
    return block;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3C-3C-method" class="method-detail ">
          <a name="method-i-3C-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">prc << g &rarr; a_proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a proc that is the composition of this proc and the given
<em>g</em>. The returned proc takes a variable number of arguments, calls
<em>g</em> with them then calls this proc with the result.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">x</span> }
<span class="ruby-identifier">g</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">x</span> }
<span class="ruby-identifier">p</span> (<span class="ruby-identifier">f</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">g</span>).<span class="ruby-identifier">call</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 16</span>
</pre>

<p>See <a href="Proc.html#method-i-3E-3E">#>></a> for detailed explanations.</p>
            

            
            <div class="method-source-code" id="3C-3C-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_compose_to_left(VALUE self, VALUE g)
{
    return rb_proc_compose_to_left(self, to_callable(g));
}
            </pre> 
            </div><!-- 3C-3C-source -->
            
          </div>

          

          
        </div><!-- 3C-3C-method -->
      
        <div id="3D-3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">proc === obj   &rarr; result_of_proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the block with <code>obj</code> as the proc&#39;s parameter like <a
href="Proc.html#method-i-call">#call</a>. This allows a proc object to be
the target of a <code>when</code> clause in a case statement.</p>
            

            
            <div class="method-source-code" id="3D-3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    /* removed */
}
            </pre> 
            </div><!-- 3D-3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-3D-method -->
      
        <div id="3E-3E-method" class="method-detail ">
          <a name="method-i-3E-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">prc >> g &rarr; a_proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a proc that is the composition of this proc and the given
<em>g</em>. The returned proc takes a variable number of arguments, calls
this proc with them then calls <em>g</em> with the result.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">x</span> }
<span class="ruby-identifier">g</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">x</span> }
<span class="ruby-identifier">p</span> (<span class="ruby-identifier">f</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-identifier">g</span>).<span class="ruby-identifier">call</span>(<span class="ruby-value">2</span>) <span class="ruby-comment">#=&gt; 8</span>
</pre>

<p><em>g</em> could be other <a href="Proc.html">Proc</a>, or <a
href="Method.html">Method</a>, or any other object responding to
<code>call</code> method:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Parser</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">text</span>)
     <span class="ruby-comment"># ...some complicated parsing logic...</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">pipeline</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">method</span>(:<span class="ruby-identifier">read</span>) <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-constant">Parser</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;data size: #{data.count}&quot;</span> }
<span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">call</span>(<span class="ruby-string">&#39;data.json&#39;</span>)
</pre>

<p>See also <a href="Method.html#method-i-3E-3E">Method#>></a> and <a
href="Method.html#method-i-3C-3C">Method#<<</a>.</p>
            

            
            <div class="method-source-code" id="3E-3E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_compose_to_right(VALUE self, VALUE g)
{
    return rb_proc_compose_to_right(self, to_callable(g));
}
            </pre> 
            </div><!-- 3E-3E-source -->
            
          </div>

          

          
        </div><!-- 3E-3E-method -->
      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">prc[params,...]        &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the block, setting the block&#39;s parameters to the values in
<em>params</em> using something close to method calling semantics. Returns
the value of the last expression evaluated in the block.</p>

<pre class="ruby"><span class="ruby-identifier">a_proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">scalar</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">values</span><span class="ruby-operator">|</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span><span class="ruby-operator">*</span><span class="ruby-identifier">scalar</span> } }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)    <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>[<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]         <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>.(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)        <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">yield</span>(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)   <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
</pre>

<p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the
parameters given.  It&#39;s syntactic sugar to hide “call”.</p>

<p>For procs created using <a href="Kernel.html#method-i-lambda">lambda</a> or
<code>-&gt;()</code> an error is generated if the wrong number of
parameters are passed to the proc.  For procs created using <a
href="Proc.html#method-c-new">::new</a> or <a
href="Kernel.html#method-i-proc">Kernel#proc</a>, extra parameters are
silently discarded and missing parameters are set to <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a_proc</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment">#=&gt; [1, nil]</span>

<span class="ruby-identifier">a_proc</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>
</pre>

<p>See also <a href="Proc.html#method-i-lambda-3F">#lambda?</a>.</p>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    /* removed */
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="arity-method" class="method-detail ">
          <a name="method-i-arity"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">arity &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of mandatory arguments. If the block is declared to take
no arguments, returns 0. If the block is known to take exactly n arguments,
returns n. If the block has optional arguments, returns -n-1, where n is
the number of mandatory arguments, with the exception for blocks that are
not lambdas and have only a finite number of optional arguments; in this
latter case, returns n. Keyword arguments will be considered as a single
additional argument, that argument being mandatory if any keyword argument
is mandatory. A <a href="Kernel.html#method-i-proc">proc</a> with no
argument declarations is the same as a block declaring <code>||</code> as
its arguments.</p>

<pre class="ruby"><span class="ruby-identifier">proc</span> {}.<span class="ruby-identifier">arity</span>                  <span class="ruby-comment">#=&gt;  0</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">||</span> }.<span class="ruby-identifier">arity</span>              <span class="ruby-comment">#=&gt;  0</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>             <span class="ruby-comment">#=&gt;  1</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>          <span class="ruby-comment">#=&gt;  2</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>       <span class="ruby-comment">#=&gt;  3</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-operator">*</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>            <span class="ruby-comment">#=&gt; -1</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">b</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>         <span class="ruby-comment">#=&gt; -2</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">b</span>, <span class="ruby-identifier">c</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>      <span class="ruby-comment">#=&gt; -3</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>:, <span class="ruby-identifier">y</span>:, <span class="ruby-identifier">z</span>:<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>   <span class="ruby-comment">#=&gt;  1</span>
<span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-operator">*</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">x</span>:, <span class="ruby-identifier">y</span>:<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>   <span class="ruby-comment">#=&gt; -2</span>

<span class="ruby-identifier">proc</span>   { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>         <span class="ruby-comment">#=&gt;  0</span>
<span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>         <span class="ruby-comment">#=&gt; -1</span>
<span class="ruby-identifier">proc</span>   { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>      <span class="ruby-comment">#=&gt;  1</span>
<span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">b</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>      <span class="ruby-comment">#=&gt; -2</span>
<span class="ruby-identifier">proc</span>   { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">b</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>    <span class="ruby-comment">#=&gt;  0</span>
<span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">b</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>    <span class="ruby-comment">#=&gt; -1</span>
<span class="ruby-identifier">proc</span>   { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>      <span class="ruby-comment">#=&gt;  1</span>
<span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span>      <span class="ruby-comment">#=&gt; -2</span>
<span class="ruby-identifier">proc</span>   { <span class="ruby-operator">|</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>), <span class="ruby-identifier">c</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span> <span class="ruby-comment">#=&gt;  1</span>
<span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span>(<span class="ruby-identifier">a</span>, <span class="ruby-identifier">b</span>), <span class="ruby-identifier">c</span>=<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span> <span class="ruby-comment">#=&gt; -2</span>
<span class="ruby-identifier">proc</span>   { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">x</span>:<span class="ruby-value">0</span>, <span class="ruby-identifier">y</span>:<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span> <span class="ruby-comment">#=&gt;  1</span>
<span class="ruby-identifier">lambda</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>, <span class="ruby-identifier">x</span>:<span class="ruby-value">0</span>, <span class="ruby-identifier">y</span>:<span class="ruby-value">0</span><span class="ruby-operator">|</span> }.<span class="ruby-identifier">arity</span> <span class="ruby-comment">#=&gt; -2</span>
</pre>
            

            
            <div class="method-source-code" id="arity-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_arity(VALUE self)
{
    int arity = rb_proc_arity(self);
    return INT2FIX(arity);
}
            </pre> 
            </div><!-- arity-source -->
            
          </div>

          

          
        </div><!-- arity-method -->
      
        <div id="binding-method" class="method-detail ">
          <a name="method-i-binding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">binding    &rarr; binding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the binding associated with <em>prc</em>.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">fred</span>(<span class="ruby-identifier">param</span>)
  <span class="ruby-identifier">proc</span> {}
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">b</span> = <span class="ruby-identifier">fred</span>(<span class="ruby-value">99</span>)
<span class="ruby-identifier">eval</span>(<span class="ruby-string">&quot;param&quot;</span>, <span class="ruby-identifier">b</span>.<span class="ruby-identifier">binding</span>)   <span class="ruby-comment">#=&gt; 99</span>
</pre>
            

            
            <div class="method-source-code" id="binding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_binding(VALUE self)
{
    VALUE bindval, binding_self = Qundef;
    rb_binding_t *bind;
    const rb_proc_t *proc;
    const rb_iseq_t *iseq = NULL;
    const struct rb_block *block;
    const rb_env_t *env = NULL;

    GetProcPtr(self, proc);
    block = &amp;proc-&gt;block;

  again:
    switch (vm_block_type(block)) {
      case block_type_iseq:
        iseq = block-&gt;as.captured.code.iseq;
        binding_self = block-&gt;as.captured.self;
        env = VM_ENV_ENVVAL_PTR(block-&gt;as.captured.ep);
        break;
      case block_type_proc:
        GetProcPtr(block-&gt;as.proc, proc);
        block = &amp;proc-&gt;block;
        goto again;
      case block_type_symbol:
        goto error;
      case block_type_ifunc:
        {
            const struct vm_ifunc *ifunc = block-&gt;as.captured.code.ifunc;
            if (IS_METHOD_PROC_IFUNC(ifunc)) {
                VALUE method = (VALUE)ifunc-&gt;data;
                VALUE name = rb_fstring_lit(&quot;&lt;empty_iseq&gt;&quot;);
                rb_iseq_t *empty;
                binding_self = method_receiver(method);
                iseq = rb_method_iseq(method);
                env = VM_ENV_ENVVAL_PTR(block-&gt;as.captured.ep);
                env = env_clone(env, method_cref(method));
                /* set empty iseq */
                empty = rb_iseq_new(NULL, name, name, Qnil, 0, ISEQ_TYPE_TOP);
                RB_OBJ_WRITE(env, &amp;env-&gt;iseq, empty);
                break;
            }
            else {
              error:
                rb_raise(rb_eArgError, &quot;Can&#39;t create Binding from C level Proc&quot;);
                return Qnil;
            }
        }
    }

    bindval = rb_binding_alloc(rb_cBinding);
    GetBindingPtr(bindval, bind);
    RB_OBJ_WRITE(bindval, &amp;bind-&gt;block.as.captured.self, binding_self);
    RB_OBJ_WRITE(bindval, &amp;bind-&gt;block.as.captured.code.iseq, env-&gt;iseq);
    rb_vm_block_ep_update(bindval, &amp;bind-&gt;block, env-&gt;ep);
    RB_OBJ_WRITTEN(bindval, Qundef, VM_ENV_ENVVAL(env-&gt;ep));

    if (iseq) {
        rb_iseq_check(iseq);
        RB_OBJ_WRITE(bindval, &amp;bind-&gt;pathobj, iseq-&gt;body-&gt;location.pathobj);
        bind-&gt;first_lineno = FIX2INT(rb_iseq_first_lineno(iseq));
    }
    else {
        RB_OBJ_WRITE(bindval, &amp;bind-&gt;pathobj,
                     rb_iseq_pathobj_new(rb_fstring_lit(&quot;(binding)&quot;), Qnil));
        bind-&gt;first_lineno = 1;
    }

    return bindval;
}
            </pre> 
            </div><!-- binding-source -->
            
          </div>

          

          
        </div><!-- binding-method -->
      
        <div id="call-method" class="method-detail ">
          <a name="method-i-call"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">call(params,...)   &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the block, setting the block&#39;s parameters to the values in
<em>params</em> using something close to method calling semantics. Returns
the value of the last expression evaluated in the block.</p>

<pre class="ruby"><span class="ruby-identifier">a_proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">scalar</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">values</span><span class="ruby-operator">|</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span><span class="ruby-operator">*</span><span class="ruby-identifier">scalar</span> } }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)    <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>[<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]         <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>.(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)        <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">yield</span>(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)   <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
</pre>

<p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the
parameters given.  It&#39;s syntactic sugar to hide “call”.</p>

<p>For procs created using <a href="Kernel.html#method-i-lambda">lambda</a> or
<code>-&gt;()</code> an error is generated if the wrong number of
parameters are passed to the proc.  For procs created using <a
href="Proc.html#method-c-new">::new</a> or <a
href="Kernel.html#method-i-proc">Kernel#proc</a>, extra parameters are
silently discarded and missing parameters are set to <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a_proc</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment">#=&gt; [1, nil]</span>

<span class="ruby-identifier">a_proc</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>
</pre>

<p>See also <a href="Proc.html#method-i-lambda-3F">#lambda?</a>.</p>
            

            
            <div class="method-source-code" id="call-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    /* removed */
}
            </pre> 
            </div><!-- call-source -->
            
          </div>

          

          
        </div><!-- call-method -->
      
        <div id="curry-method" class="method-detail ">
          <a name="method-i-curry"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">curry         &rarr; a_proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">curry(arity)  &rarr; a_proc</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a curried proc. If the optional <em>arity</em> argument is given,
it determines the number of arguments. A curried proc receives some
arguments. If a sufficient number of arguments are supplied, it passes the
supplied arguments to the original proc and returns the result. Otherwise,
returns another curried proc that takes the rest of arguments.</p>

<pre class="ruby"><span class="ruby-identifier">b</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">z</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">x</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">y</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">z</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>][<span class="ruby-value">2</span>][<span class="ruby-value">3</span>]           <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>][<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]        <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">5</span>)[<span class="ruby-value">1</span>][<span class="ruby-value">2</span>][<span class="ruby-value">3</span>][<span class="ruby-value">4</span>][<span class="ruby-value">5</span>]  <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">5</span>)[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>][<span class="ruby-value">3</span>, <span class="ruby-value">4</span>][<span class="ruby-value">5</span>]  <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">1</span>)[<span class="ruby-value">1</span>]              <span class="ruby-comment">#=&gt; 1</span>

<span class="ruby-identifier">b</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">z</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">w</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">x</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">y</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">z</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-value">0</span>, <span class="ruby-operator">&amp;</span>:<span class="ruby-operator">+</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>][<span class="ruby-value">2</span>][<span class="ruby-value">3</span>]           <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>][<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]        <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">5</span>)[<span class="ruby-value">1</span>][<span class="ruby-value">2</span>][<span class="ruby-value">3</span>][<span class="ruby-value">4</span>][<span class="ruby-value">5</span>]  <span class="ruby-comment">#=&gt; 15</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">5</span>)[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>][<span class="ruby-value">3</span>, <span class="ruby-value">4</span>][<span class="ruby-value">5</span>]  <span class="ruby-comment">#=&gt; 15</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">1</span>)[<span class="ruby-value">1</span>]              <span class="ruby-comment">#=&gt; 1</span>

<span class="ruby-identifier">b</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">z</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">x</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">y</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">z</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>][<span class="ruby-value">2</span>][<span class="ruby-value">3</span>]           <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>][<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]        <span class="ruby-comment">#=&gt; wrong number of arguments (given 4, expected 3)</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">5</span>)                 <span class="ruby-comment">#=&gt; wrong number of arguments (given 5, expected 3)</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">1</span>)                 <span class="ruby-comment">#=&gt; wrong number of arguments (given 1, expected 3)</span>

<span class="ruby-identifier">b</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>, <span class="ruby-identifier">z</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">w</span><span class="ruby-operator">|</span> (<span class="ruby-identifier">x</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">y</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">z</span><span class="ruby-operator">||</span><span class="ruby-value">0</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-value">0</span>, <span class="ruby-operator">&amp;</span>:<span class="ruby-operator">+</span>) }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>][<span class="ruby-value">2</span>][<span class="ruby-value">3</span>]           <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>][<span class="ruby-value">3</span>, <span class="ruby-value">4</span>]        <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">5</span>)[<span class="ruby-value">1</span>][<span class="ruby-value">2</span>][<span class="ruby-value">3</span>][<span class="ruby-value">4</span>][<span class="ruby-value">5</span>]  <span class="ruby-comment">#=&gt; 15</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">5</span>)[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>][<span class="ruby-value">3</span>, <span class="ruby-value">4</span>][<span class="ruby-value">5</span>]  <span class="ruby-comment">#=&gt; 15</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>(<span class="ruby-value">1</span>)                 <span class="ruby-comment">#=&gt; wrong number of arguments (given 1, expected 3)</span>

<span class="ruby-identifier">b</span> = <span class="ruby-identifier">proc</span> { :<span class="ruby-identifier">foo</span> }
<span class="ruby-identifier">p</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">curry</span>[]                  <span class="ruby-comment">#=&gt; :foo</span>
</pre>
            

            
            <div class="method-source-code" id="curry-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_curry(int argc, const VALUE *argv, VALUE self)
{
    int sarity, max_arity, min_arity = rb_proc_min_max_arity(self, &amp;max_arity);
    VALUE arity;

    if (rb_check_arity(argc, 0, 1) == 0 || NIL_P(arity = argv[0])) {
        arity = INT2FIX(min_arity);
    }
    else {
        sarity = FIX2INT(arity);
        if (rb_proc_lambda_p(self)) {
            rb_check_arity(sarity, min_arity, max_arity);
        }
    }

    return make_curry_proc(self, rb_ary_new(), arity);
}
            </pre> 
            </div><!-- curry-source -->
            
          </div>

          

          
        </div><!-- curry-method -->
      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash   &rarr;  integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a hash value corresponding to proc body.</p>

<p>See also <a href="Object.html#method-i-hash">Object#hash</a>.</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_hash(VALUE self)
{
    st_index_t hash;
    hash = rb_hash_start(0);
    hash = rb_hash_proc(hash, self);
    hash = rb_hash_end(hash);
    return ST2FIX(hash);
}
            </pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->
      
        <div id="inspect-method" class="method-detail method-alias">
          <a name="method-i-inspect"></a>

          
          <div class="method-heading">
            <span class="method-name">inspect</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Proc.html#method-i-to_s">to_s</a>
          </div>
          
        </div><!-- inspect-method -->
      
        <div id="lambda-3F-method" class="method-detail ">
          <a name="method-i-lambda-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lambda? &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if a <a href="Proc.html">Proc</a> object is
lambda. <code>false</code> if non-lambda.</p>

<p>The lambda-ness affects argument handling and the behavior of
<code>return</code> and <code>break</code>.</p>

<p>A <a href="Proc.html">Proc</a> object generated by <code>proc</code>
ignores extra arguments.</p>

<pre class="ruby"><span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>)    <span class="ruby-comment">#=&gt; [1,2]</span>
</pre>

<p>It provides <code>nil</code> for missing arguments.</p>

<pre class="ruby"><span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)        <span class="ruby-comment">#=&gt; [1,nil]</span>
</pre>

<p>It expands a single array argument.</p>

<pre class="ruby"><span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }.<span class="ruby-identifier">call</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>])    <span class="ruby-comment">#=&gt; [1,2]</span>
</pre>

<p>A <a href="Proc.html">Proc</a> object generated by <code>lambda</code>
doesn&#39;t have such tricks.</p>

<pre class="ruby"><span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>)  <span class="ruby-comment">#=&gt; ArgumentError</span>
<span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)      <span class="ruby-comment">#=&gt; ArgumentError</span>
<span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }.<span class="ruby-identifier">call</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>])  <span class="ruby-comment">#=&gt; ArgumentError</span>
</pre>

<p><a href="Proc.html#method-i-lambda-3F">#lambda?</a> is a predicate for the
tricks. It returns <code>true</code> if no tricks apply.</p>

<pre class="ruby"><span class="ruby-identifier">lambda</span> {}.<span class="ruby-identifier">lambda?</span>            <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">proc</span> {}.<span class="ruby-identifier">lambda?</span>              <span class="ruby-comment">#=&gt; false</span>
</pre>

<p><a href="Proc.html#method-c-new">::new</a> is the same as
<code>proc</code>.</p>

<pre class="ruby"><span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {}.<span class="ruby-identifier">lambda?</span>          <span class="ruby-comment">#=&gt; false</span>
</pre>

<p><code>lambda</code>, <code>proc</code> and <a
href="Proc.html#method-c-new">::new</a> preserve the tricks of a <a
href="Proc.html">Proc</a> object given by <code>&amp;</code> argument.</p>

<pre class="ruby"><span class="ruby-identifier">lambda</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">lambda</span> {}).<span class="ruby-identifier">lambda?</span>   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">proc</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">lambda</span> {}).<span class="ruby-identifier">lambda?</span>     <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">lambda</span> {}).<span class="ruby-identifier">lambda?</span> <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">lambda</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> {}).<span class="ruby-identifier">lambda?</span>     <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">proc</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> {}).<span class="ruby-identifier">lambda?</span>       <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> {}).<span class="ruby-identifier">lambda?</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>A <a href="Proc.html">Proc</a> object generated by <code>&amp;</code>
argument has the tricks</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">n</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>) <span class="ruby-identifier">b</span>.<span class="ruby-identifier">lambda?</span> <span class="ruby-keyword">end</span>
<span class="ruby-identifier">n</span> {}                         <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>The <code>&amp;</code> argument preserves the tricks if a <a
href="Proc.html">Proc</a> object is given by <code>&amp;</code> argument.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">lambda</span> {})                <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">n</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> {})                  <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">n</span>(<span class="ruby-operator">&amp;</span><span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {})              <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>A <a href="Proc.html">Proc</a> object converted from a method has no
tricks.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">m</span>() <span class="ruby-keyword">end</span>
<span class="ruby-identifier">method</span>(:<span class="ruby-identifier">m</span>).<span class="ruby-identifier">to_proc</span>.<span class="ruby-identifier">lambda?</span>   <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">n</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">method</span>(:<span class="ruby-identifier">m</span>))               <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">n</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">method</span>(:<span class="ruby-identifier">m</span>).<span class="ruby-identifier">to_proc</span>)       <span class="ruby-comment">#=&gt; true</span>
</pre>

<p><code>define_method</code> is treated the same as method definition. The
defined method has no tricks.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-identifier">define_method</span>(:<span class="ruby-identifier">d</span>) {}
<span class="ruby-keyword">end</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">d</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)       <span class="ruby-comment">#=&gt; ArgumentError</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">method</span>(:<span class="ruby-identifier">d</span>).<span class="ruby-identifier">to_proc</span>.<span class="ruby-identifier">lambda?</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>

<p><code>define_method</code> always defines a method without the tricks, even
if a non-lambda <a href="Proc.html">Proc</a> object is given. This is the
only exception for which the tricks are not preserved.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-identifier">define_method</span>(:<span class="ruby-identifier">e</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">proc</span> {})
<span class="ruby-keyword">end</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">e</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)       <span class="ruby-comment">#=&gt; ArgumentError</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">method</span>(:<span class="ruby-identifier">e</span>).<span class="ruby-identifier">to_proc</span>.<span class="ruby-identifier">lambda?</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>This exception ensures that methods never have tricks and makes it easy to
have wrappers to define methods that behave as usual.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">def2</span>(<span class="ruby-identifier">name</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">body</span>)
    <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">name</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">body</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">def2</span>(:<span class="ruby-identifier">f</span>) {}
<span class="ruby-keyword">end</span>
<span class="ruby-constant">C</span>.<span class="ruby-identifier">new</span>.<span class="ruby-identifier">f</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)       <span class="ruby-comment">#=&gt; ArgumentError</span>
</pre>

<p>The wrapper <em>def2</em> defines a method which has no tricks.</p>
            

            
            <div class="method-source-code" id="lambda-3F-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_proc_lambda_p(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    return proc-&gt;is_lambda ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- lambda-3F-source -->
            
          </div>

          

          
        </div><!-- lambda-3F-method -->
      
        <div id="parameters-method" class="method-detail ">
          <a name="method-i-parameters"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">parameters  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the parameter information of this proc.</p>

<pre class="ruby"><span class="ruby-identifier">prc</span> = <span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>=<span class="ruby-value">42</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">other</span><span class="ruby-operator">|</span>}
<span class="ruby-identifier">prc</span>.<span class="ruby-identifier">parameters</span>  <span class="ruby-comment">#=&gt; [[:req, :x], [:opt, :y], [:rest, :other]]</span>
</pre>
            

            
            <div class="method-source-code" id="parameters-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_proc_parameters(VALUE self)
{
    int is_proc;
    const rb_iseq_t *iseq = rb_proc_get_iseq(self, &amp;is_proc);
    if (!iseq) {
        return rb_unnamed_parameters(rb_proc_arity(self));
    }
    return rb_iseq_parameters(iseq, is_proc);
}
            </pre> 
            </div><!-- parameters-source -->
            
          </div>

          

          
        </div><!-- parameters-method -->
      
        <div id="ruby2_keywords-method" class="method-detail ">
          <a name="method-i-ruby2_keywords"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ruby2_keywords &rarr; proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Marks the proc as passing keywords through a normal argument splat. This
should only be called on procs that accept an argument splat
(<code>*args</code>) but not explicit keywords or a keyword splat.  It
marks the proc such that if the proc is called with keyword arguments, the
final hash argument is marked with a special flag such that if it is the
final element of a normal argument splat to another method call, and that
method call does not include explicit keywords or a keyword splat, the
final element is interpreted as keywords.  In other words, keywords will be
passed through the proc to other methods.</p>

<p>This should only be used for procs that delegate keywords to another
method, and only for backwards compatibility with Ruby versions before 2.7.</p>

<p>This method will probably be removed at some point, as it exists only for
backwards compatibility. As it does not exist in Ruby versions before 2.7,
check that the proc responds to this method before calling it. Also, be
aware that if this method is removed, the behavior of the proc will change
so that it does not pass through keywords.</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">Mod</span>
  <span class="ruby-identifier">foo</span> = <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span>(<span class="ruby-identifier">meth</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">send</span>(:<span class="ruby-node">&quot;do_#{meth}&quot;</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">foo</span>.<span class="ruby-identifier">ruby2_keywords</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">foo</span>.<span class="ruby-identifier">respond_to?</span>(:<span class="ruby-identifier">ruby2_keywords</span>)
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="ruby2_keywords-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_ruby2_keywords(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    rb_check_frozen(procval);

    if (proc-&gt;is_from_method) {
            rb_warn(&quot;Skipping set of ruby2_keywords flag for proc (proc created from method)&quot;);
            return procval;
    }

    switch (proc-&gt;block.type) {
      case block_type_iseq:
        if (proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.has_rest &amp;&amp;
                !proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.has_kw &amp;&amp;
                !proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.has_kwrest) {
            proc-&gt;block.as.captured.code.iseq-&gt;body-&gt;param.flags.ruby2_keywords = 1;
        }
        else {
            rb_warn(&quot;Skipping set of ruby2_keywords flag for proc (proc accepts keywords or proc does not accept argument splat)&quot;);
        }
        break;
      default:
        rb_warn(&quot;Skipping set of ruby2_keywords flag for proc (proc not defined in Ruby)&quot;);
        break;
    }

    return procval;
}
            </pre> 
            </div><!-- ruby2_keywords-source -->
            
          </div>

          

          
        </div><!-- ruby2_keywords-method -->
      
        <div id="source_location-method" class="method-detail ">
          <a name="method-i-source_location"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">source_location  &rarr; [String, Integer]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the Ruby source filename and line number containing this proc or
<code>nil</code> if this proc was not defined in Ruby (i.e. native).</p>
            

            
            <div class="method-source-code" id="source_location-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_proc_location(VALUE self)
{
    return iseq_location(rb_proc_get_iseq(self, 0));
}
            </pre> 
            </div><!-- source_location-source -->
            
          </div>

          

          
        </div><!-- source_location-method -->
      
        <div id="to_proc-method" class="method-detail ">
          <a name="method-i-to_proc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_proc &rarr; proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Part of the protocol for converting objects to <a href="Proc.html">Proc</a>
objects. Instances of class <a href="Proc.html">Proc</a> simply return
themselves.</p>
            

            
            <div class="method-source-code" id="to_proc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_to_proc(VALUE self)
{
    return self;
}
            </pre> 
            </div><!-- to_proc-source -->
            
          </div>

          

          
        </div><!-- to_proc-method -->
      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the unique identifier for this proc, along with an indication of
where the proc was defined.</p>
            

            
            <div class="method-source-code" id="to_s-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_to_s(VALUE self)
{
    const rb_proc_t *proc;
    GetProcPtr(self, proc);
    return rb_block_to_s(self, &amp;proc-&gt;block, proc-&gt;is_lambda ? &quot; (lambda)&quot; : NULL);
}
            </pre> 
            </div><!-- to_s-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Proc.html#method-i-inspect">inspect</a>
          </div>
          

          
        </div><!-- to_s-method -->
      
        <div id="yield-method" class="method-detail ">
          <a name="method-i-yield"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">yield(params,...)  &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Invokes the block, setting the block&#39;s parameters to the values in
<em>params</em> using something close to method calling semantics. Returns
the value of the last expression evaluated in the block.</p>

<pre class="ruby"><span class="ruby-identifier">a_proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">scalar</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">values</span><span class="ruby-operator">|</span> <span class="ruby-identifier">values</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span><span class="ruby-operator">*</span><span class="ruby-identifier">scalar</span> } }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)    <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>[<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]         <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>.(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)        <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">yield</span>(<span class="ruby-value">9</span>, <span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)   <span class="ruby-comment">#=&gt; [9, 18, 27]</span>
</pre>

<p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the
parameters given.  It&#39;s syntactic sugar to hide “call”.</p>

<p>For procs created using <a href="Kernel.html#method-i-lambda">lambda</a> or
<code>-&gt;()</code> an error is generated if the wrong number of
parameters are passed to the proc.  For procs created using <a
href="Proc.html#method-c-new">::new</a> or <a
href="Kernel.html#method-i-proc">Kernel#proc</a>, extra parameters are
silently discarded and missing parameters are set to <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">a_proc</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment">#=&gt; [1, nil]</span>

<span class="ruby-identifier">a_proc</span> = <span class="ruby-identifier">lambda</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span>] }
<span class="ruby-identifier">a_proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>)   <span class="ruby-comment"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>
</pre>

<p>See also <a href="Proc.html#method-i-lambda-3F">#lambda?</a>.</p>
            

            
            <div class="method-source-code" id="yield-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    /* removed */
}
            </pre> 
            </div><!-- yield-source -->
            
          </div>

          

          
        </div><!-- yield-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Proc_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Proc_versioned").load("/associated/2.7.1/Proc.ihtml");</script> <div id='tx_Proc' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Proc").load("/associated/Proc.ihtml");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2.7.1</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>. <a href="http://neurogami.com">Hack your world.  Feed your head.  Live curious</a>.  <div class='oio-inline'><ins data-revive-zoneid="1" data-revive-id="58924a5717c091dfee6dda3f7d38c4d7"></ins><script async src="//ras.ruby-doc.org/vvv/delivery/thesinkjs.php"></script></div></p>
 
       <p><small>Generated with Ruby-doc Rdoc Generator 0.42.0</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.ihtml");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
	} 

   //function loadInline(json){
   // for (var lookFor in json) {
    //  $(lookFor).after(json[lookFor]);
    // }
  // } // end loadInline


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2.7.1/plus_Proc.ihtml', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


//     $.ajax({
//     dataType: "json",
//      url: '/associated/2.7.1/inline_Proc.js',
//      success: function(json) {
// 			setTimeout(function() {
// 				loadInline(json);
// 				}, 2000);
// 			}
//    });

		});
</script>
		
</body>
</html>


