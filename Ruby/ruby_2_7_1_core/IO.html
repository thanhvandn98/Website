<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.42.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : IO  -   Ruby 2.7.1 ' />
  <meta content="2020-04-01 15:56:50 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = false-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: IO (Ruby 2.7.1) </title>
  <link rel="stylesheet" href="css/associated.css" type="text/css" >
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >
    <link rel="stylesheet" href="css/carbon17.css" type="text/css" >


  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 


   
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

   <link rel="stylesheet" href="css/extra.css" type="text/css" >
  <script  src="/js/extra.js"  ></script>


</head>

<body id="top" class="class rdocstar">

<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 2.7.1 NOT FOUND -->
</div> <!-- end action bar -->
 <div class='wrapper'>
  
   <!-- carbon17 added here 2017-09-09 -->
 

   <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>file.c</li>      
            
          
          <li class='in-file'>io.c</li>      
            
          
          <li class='in-file'>io.rb</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">MODULE</span> <a href="IO/WaitReadable.html">IO::WaitReadable</a></li>
          
          <li><span class="type">MODULE</span> <a href="IO/WaitWritable.html">IO::WaitWritable</a></li>
          
          <li><span class="type">CLASS</span> <a href="IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
          
          <li><span class="type">CLASS</span> <a href="IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
          
          <li><span class="type">CLASS</span> <a href="IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
          
          <li><span class="type">CLASS</span> <a href="IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
          
          <li><span class="type">CLASS</span> <a href="IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
          
          <li><span class="type">CLASS</span> <a href="IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-binread">::binread</a></li>
          
          <li><a href="#method-c-binwrite">::binwrite</a></li>
          
          <li><a href="#method-c-copy_stream">::copy_stream</a></li>
          
          <li><a href="#method-c-for_fd">::for_fd</a></li>
          
          <li><a href="#method-c-foreach">::foreach</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-open">::open</a></li>
          
          <li><a href="#method-c-pipe">::pipe</a></li>
          
          <li><a href="#method-c-popen">::popen</a></li>
          
          <li><a href="#method-c-read">::read</a></li>
          
          <li><a href="#method-c-readlines">::readlines</a></li>
          
          <li><a href="#method-c-select">::select</a></li>
          
          <li><a href="#method-c-sysopen">::sysopen</a></li>
          
          <li><a href="#method-c-try_convert">::try_convert</a></li>
          
          <li><a href="#method-c-write">::write</a></li>
          
          <li><a href="#method-i-3C-3C">#<<</a></li>
          
          <li><a href="#method-i-advise">#advise</a></li>
          
          <li><a href="#method-i-autoclose-3D">#autoclose=</a></li>
          
          <li><a href="#method-i-autoclose-3F">#autoclose?</a></li>
          
          <li><a href="#method-i-binmode">#binmode</a></li>
          
          <li><a href="#method-i-binmode-3F">#binmode?</a></li>
          
          <li><a href="#method-i-bytes">#bytes</a></li>
          
          <li><a href="#method-i-chars">#chars</a></li>
          
          <li><a href="#method-i-close">#close</a></li>
          
          <li><a href="#method-i-close_on_exec-3D">#close_on_exec=</a></li>
          
          <li><a href="#method-i-close_on_exec-3F">#close_on_exec?</a></li>
          
          <li><a href="#method-i-close_read">#close_read</a></li>
          
          <li><a href="#method-i-close_write">#close_write</a></li>
          
          <li><a href="#method-i-closed-3F">#closed?</a></li>
          
          <li><a href="#method-i-codepoints">#codepoints</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_byte">#each_byte</a></li>
          
          <li><a href="#method-i-each_char">#each_char</a></li>
          
          <li><a href="#method-i-each_codepoint">#each_codepoint</a></li>
          
          <li><a href="#method-i-each_line">#each_line</a></li>
          
          <li><a href="#method-i-eof">#eof</a></li>
          
          <li><a href="#method-i-eof-3F">#eof?</a></li>
          
          <li><a href="#method-i-external_encoding">#external_encoding</a></li>
          
          <li><a href="#method-i-fcntl">#fcntl</a></li>
          
          <li><a href="#method-i-fdatasync">#fdatasync</a></li>
          
          <li><a href="#method-i-fileno">#fileno</a></li>
          
          <li><a href="#method-i-flush">#flush</a></li>
          
          <li><a href="#method-i-fsync">#fsync</a></li>
          
          <li><a href="#method-i-getbyte">#getbyte</a></li>
          
          <li><a href="#method-i-getc">#getc</a></li>
          
          <li><a href="#method-i-gets">#gets</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-internal_encoding">#internal_encoding</a></li>
          
          <li><a href="#method-i-ioctl">#ioctl</a></li>
          
          <li><a href="#method-i-isatty">#isatty</a></li>
          
          <li><a href="#method-i-lineno">#lineno</a></li>
          
          <li><a href="#method-i-lineno-3D">#lineno=</a></li>
          
          <li><a href="#method-i-lines">#lines</a></li>
          
          <li><a href="#method-i-pid">#pid</a></li>
          
          <li><a href="#method-i-pos">#pos</a></li>
          
          <li><a href="#method-i-pos-3D">#pos=</a></li>
          
          <li><a href="#method-i-pread">#pread</a></li>
          
          <li><a href="#method-i-print">#print</a></li>
          
          <li><a href="#method-i-printf">#printf</a></li>
          
          <li><a href="#method-i-putc">#putc</a></li>
          
          <li><a href="#method-i-puts">#puts</a></li>
          
          <li><a href="#method-i-pwrite">#pwrite</a></li>
          
          <li><a href="#method-i-read">#read</a></li>
          
          <li><a href="#method-i-read_nonblock">#read_nonblock</a></li>
          
          <li><a href="#method-i-readbyte">#readbyte</a></li>
          
          <li><a href="#method-i-readchar">#readchar</a></li>
          
          <li><a href="#method-i-readline">#readline</a></li>
          
          <li><a href="#method-i-readlines">#readlines</a></li>
          
          <li><a href="#method-i-readpartial">#readpartial</a></li>
          
          <li><a href="#method-i-reopen">#reopen</a></li>
          
          <li><a href="#method-i-rewind">#rewind</a></li>
          
          <li><a href="#method-i-seek">#seek</a></li>
          
          <li><a href="#method-i-set_encoding">#set_encoding</a></li>
          
          <li><a href="#method-i-set_encoding_by_bom">#set_encoding_by_bom</a></li>
          
          <li><a href="#method-i-stat">#stat</a></li>
          
          <li><a href="#method-i-sync">#sync</a></li>
          
          <li><a href="#method-i-sync-3D">#sync=</a></li>
          
          <li><a href="#method-i-sysread">#sysread</a></li>
          
          <li><a href="#method-i-sysseek">#sysseek</a></li>
          
          <li><a href="#method-i-syswrite">#syswrite</a></li>
          
          <li><a href="#method-i-tell">#tell</a></li>
          
          <li><a href="#method-i-to_i">#to_i</a></li>
          
          <li><a href="#method-i-to_io">#to_io</a></li>
          
          <li><a href="#method-i-tty-3F">#tty?</a></li>
          
          <li><a href="#method-i-ungetbyte">#ungetbyte</a></li>
          
          <li><a href="#method-i-ungetc">#ungetc</a></li>
          
          <li><a href="#method-i-write">#write</a></li>
          
          <li><a href="#method-i-write_nonblock">#write_nonblock</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="File/Constants.html">File::Constants</a></li>
        
        
        
          <li><a class="include" href="Enumerable.html">Enumerable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id='files'>
        
          
          <li class="file"><a href="./_lib/racc/rdoc/grammar_en_rdoc.html">grammar.en.rdoc</a></li>
        
          
          <li class="file"><a href="./_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./COPYING_ja.html">COPYING.ja</a></li>
        
          
          <li class="file"><a href="./README_EXT.html">README.EXT</a></li>
        
          
          <li class="file"><a href="./README_EXT_ja.html">README.EXT.ja</a></li>
        
          
          <li class="file"><a href="./configure_ac.html">configure.ac</a></li>
        
          
          <li class="file"><a href="./doc/bug_triaging_rdoc.html">bug_triaging.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributors_rdoc.html">contributors.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/extension_ja_rdoc.html">extension.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/extension_rdoc.html">extension.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/signals_rdoc.html">signals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/comments_rdoc.html">comments.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="./lex_c_blt.html">lex.c.blt</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./ARGF.html">ARGF</a></li>
        
          
          
          <li><a href="./ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="./Array.html">Array</a></li>
        
          
          
          <li><a href="./BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="./Binding.html">Binding</a></li>
        
          
          
          <li><a href="./Class.html">Class</a></li>
        
          
          
          <li><a href="./ClosedQueueError.html">ClosedQueueError</a></li>
        
          
          
          <li><a href="./Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="./Complex.html">Complex</a></li>
        
          
          
          <li><a href="./ConditionVariable.html">ConditionVariable</a></li>
        
          
          
          <li><a href="./Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="./Data.html">Data</a></li>
        
          
          
          <li><a href="./Dir.html">Dir</a></li>
        
          
          
          <li><a href="./ENV.html">ENV</a></li>
        
          
          
          <li><a href="./EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="./Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="./Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="./Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="./Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="./Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="./Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="./EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="./Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="./Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="./Enumerator/ArithmeticSequence.html">Enumerator::ArithmeticSequence</a></li>
        
          
          
          <li><a href="./Enumerator/Chain.html">Enumerator::Chain</a></li>
        
          
          
          <li><a href="./Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="./Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="./Enumerator/Producer.html">Enumerator::Producer</a></li>
        
          
          
          <li><a href="./Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="./Errno.html">Errno</a></li>
        
          
          
          <li><a href="./Exception.html">Exception</a></li>
        
          
          
          <li><a href="./FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="./Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="./FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="./File.html">File</a></li>
        
          
          
          <li><a href="./File/Constants.html">File::Constants</a></li>
        
          
          
          <li><a href="./File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="./FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="./FrozenError.html">FrozenError</a></li>
        
          
          
          <li><a href="./GC.html">GC</a></li>
        
          
          
          <li><a href="./GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="./Hash.html">Hash</a></li>
        
          
          
          <li><a href="./IO.html">IO</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="./IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="./IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="./IOError.html">IOError</a></li>
        
          
          
          <li><a href="./IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="./LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="./LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="./Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="./MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="./Math.html">Math</a></li>
        
          
          
          <li><a href="./Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="./Method.html">Method</a></li>
        
          
          
          <li><a href="./Module.html">Module</a></li>
        
          
          
          <li><a href="./Mutex.html">Mutex</a></li>
        
          
          
          <li><a href="./NameError.html">NameError</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./NoMatchingPatternError.html">NoMatchingPatternError</a></li>
        
          
          
          <li><a href="./NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="./NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="./NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="./Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="./Object.html">Object</a></li>
        
          
          
          <li><a href="./ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="./ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="./Pool.html">Pool</a></li>
        
          
          
          <li><a href="./Proc.html">Proc</a></li>
        
          
          
          <li><a href="./Process.html">Process</a></li>
        
          
          
          <li><a href="./Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="./Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="./Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="./Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="./Queue.html">Queue</a></li>
        
          
          
          <li><a href="./Random.html">Random</a></li>
        
          
          
          <li><a href="./Random/Formatter.html">Random::Formatter</a></li>
        
          
          
          <li><a href="./Range.html">Range</a></li>
        
          
          
          <li><a href="./RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="./Rational.html">Rational</a></li>
        
          
          
          <li><a href="./Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="./RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="./Ripper.html">Ripper</a></li>
        
          
          
          <li><a href="./RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="./RubyVM/AbstractSyntaxTree.html">RubyVM::AbstractSyntaxTree</a></li>
        
          
          
          <li><a href="./RubyVM/AbstractSyntaxTree/Node.html">RubyVM::AbstractSyntaxTree::Node</a></li>
        
          
          
          <li><a href="./RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="./RubyVM/MJIT.html">RubyVM::MJIT</a></li>
        
          
          
          <li><a href="./RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="./ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="./SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="./Signal.html">Signal</a></li>
        
          
          
          <li><a href="./SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="./SizedQueue.html">SizedQueue</a></li>
        
          
          
          <li><a href="./StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="./StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
          
          
          <li><a href="./Struct.html">Struct</a></li>
        
          
          
          <li><a href="./Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="./SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="./SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="./SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="./SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="./Thread.html">Thread</a></li>
        
          
          
          <li><a href="./Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="./ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="./ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
          
          
          <li><a href="./TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="./TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="./TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="./UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="./UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="./UnicodeNormalize.html">UnicodeNormalize</a></li>
        
          
          
          <li><a href="./Warning.html">Warning</a></li>
        
          
          
          <li><a href="./ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="./fatal.html">fatal</a></li>
        
          
          
          <li><a href="./unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">IO</h1>

    <div id="description" class="description">
      
<p>The <a href="IO.html">IO</a> class is the basis for all input and output in
Ruby. An I/O stream may be <em>duplexed</em> (that is, bidirectional), and
so may use more than one native operating system stream.</p>

<p>Many of the examples in this section use the <a href="File.html">File</a>
class, the only standard subclass of <a href="IO.html">IO</a>. The two
classes are closely associated.  Like the <a href="File.html">File</a>
class, the Socket library subclasses from <a href="IO.html">IO</a> (such as
TCPSocket or UDPSocket).</p>

<p>The <a href="Kernel.html#method-i-open">Kernel#open</a> method can create
an <a href="IO.html">IO</a> (or <a href="File.html">File</a>) object for
these types of arguments:</p>
<ul><li>
<p>A plain string represents a filename suitable for the underlying operating
system.</p>
</li><li>
<p>A string starting with <code>&quot;|&quot;</code> indicates a subprocess.
The remainder of the string following the <code>&quot;|&quot;</code> is
invoked as a process with appropriate input/output channels connected to
it.</p>
</li><li>
<p>A string equal to <code>&quot;|-&quot;</code> will create another Ruby
instance as a subprocess.</p>
</li></ul>

<p>The <a href="IO.html">IO</a> may be opened with different file modes
(read-only, write-only) and encodings for proper conversion.  See <a
href="IO.html#method-c-new">::new</a> for these options.  See <a
href="Kernel.html#method-i-open">Kernel#open</a> for details of the various
command formats described above.</p>

<p><a href="IO.html#method-c-popen">::popen</a>, the Open3 library, or 
Process#spawn may also be used to communicate with subprocesses through an
<a href="IO.html">IO</a>.</p>

<p>Ruby will convert pathnames between different operating system conventions
if possible.  For instance, on a Windows system the filename
<code>&quot;/gumby/ruby/test.rb&quot;</code> will be opened as
<code>&quot;\gumby\ruby\test.rb&quot;</code>.  When specifying a
Windows-style filename in a Ruby string, remember to escape the
backslashes:</p>

<pre class="ruby"><span class="ruby-string">&quot;C:\\gumby\\ruby\\test.rb&quot;</span>
</pre>

<p>Our examples here will use the Unix-style forward slashes;
File::ALT_SEPARATOR can be used to get the platform-specific separator
character.</p>

<p>The global constant <a href="ARGF.html">ARGF</a> (also accessible as
<code>$&lt;</code>) provides an IO-like stream which allows access to all
files mentioned on the command line (or STDIN if no files are mentioned).
<a href="ARGF.html#method-i-path">ARGF#path</a> and its alias <a
href="ARGF.html#method-i-filename">ARGF#filename</a> are provided to access
the name of the file currently being read.</p>

<h2 id="class-IO-label-io-2Fconsole">io/console<span><a href="#class-IO-label-io-2Fconsole">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The io/console extension provides methods for interacting with the console.
The console can be accessed from IO.console or the standard
input/output/error <a href="IO.html">IO</a> objects.</p>

<p>Requiring io/console adds the following methods:</p>
<ul><li>
<p>IO::console</p>
</li><li>
<p>IO#raw</p>
</li><li>
<p>IO#raw!</p>
</li><li>
<p>IO#cooked</p>
</li><li>
<p>IO#cooked!</p>
</li><li>
<p>IO#getch</p>
</li><li>
<p>IO#echo=</p>
</li><li>
<p>IO#echo?</p>
</li><li>
<p>IO#noecho</p>
</li><li>
<p>IO#winsize</p>
</li><li>
<p>IO#winsize=</p>
</li><li>
<p>IO#iflush</p>
</li><li>
<p>IO#ioflush</p>
</li><li>
<p>IO#oflush</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;io/console&#39;</span>
<span class="ruby-identifier">rows</span>, <span class="ruby-identifier">columns</span> = <span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">winsize</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Your screen is #{columns} wide and #{rows} tall&quot;</span>
</pre>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="EWOULDBLOCKWaitReadable">EWOULDBLOCKWaitReadable</a></dt>
          
          <dd class="description"><p><a href="IO/EAGAINWaitReadable.html">EAGAINWaitReadable</a></p></dd>
          
        
          <dt><a name="EWOULDBLOCKWaitWritable">EWOULDBLOCKWaitWritable</a></dt>
          
          <dd class="description"><p><a href="IO/EAGAINWaitWritable.html">EAGAINWaitWritable</a></p></dd>
          
        
          <dt><a name="SEEK_CUR">SEEK_CUR</a></dt>
          
          <dd class="description"><p>Set I/O position from the current position</p></dd>
          
        
          <dt><a name="SEEK_DATA">SEEK_DATA</a></dt>
          
          <dd class="description"><p>Set I/O position to the next location containing data</p></dd>
          
        
          <dt><a name="SEEK_END">SEEK_END</a></dt>
          
          <dd class="description"><p>Set I/O position from the end</p></dd>
          
        
          <dt><a name="SEEK_HOLE">SEEK_HOLE</a></dt>
          
          <dd class="description"><p>Set I/O position to the next hole</p></dd>
          
        
          <dt><a name="SEEK_SET">SEEK_SET</a></dt>
          
          <dd class="description"><p>Set I/O position from the beginning</p></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="binread-method" class="method-detail ">
          <a name="method-c-binread"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">binread(name, [length [, offset]] )   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Opens the file, optionally seeks to the given <em>offset</em>, then returns
<em>length</em> bytes (defaulting to the rest of the file). binread ensures
the file is closed before returning.  The open mode would be
<code>&quot;rb:ASCII-8BIT&quot;</code>.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">binread</span>(<span class="ruby-string">&quot;testfile&quot;</span>)           <span class="ruby-comment">#=&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">binread</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-value">20</span>)       <span class="ruby-comment">#=&gt; &quot;This is line one\nThi&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">binread</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-value">20</span>, <span class="ruby-value">10</span>)   <span class="ruby-comment">#=&gt; &quot;ne one\nThis is line &quot;</span>
</pre>
            

            
            <div class="method-source-code" id="binread-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_binread(int argc, VALUE *argv, VALUE io)
{
    VALUE offset;
    struct foreach_arg arg;
    enum {
        fmode = FMODE_READABLE|FMODE_BINMODE,
        oflags = O_RDONLY
#ifdef O_BINARY
                |O_BINARY
#endif
    };
    convconfig_t convconfig = {NULL, NULL, 0, Qnil};

    rb_scan_args(argc, argv, &quot;12&quot;, NULL, NULL, &amp;offset);
    FilePathValue(argv[0]);
    convconfig.enc = rb_ascii8bit_encoding();
    arg.io = rb_io_open_generic(io, argv[0], oflags, fmode, &amp;convconfig, 0);
    if (NIL_P(arg.io)) return Qnil;
    arg.argv = argv+1;
    arg.argc = (argc &gt; 1) ? 1 : 0;
    if (!NIL_P(offset)) {
        struct seek_arg sarg;
        int state = 0;
        sarg.io = arg.io;
        sarg.offset = offset;
        sarg.mode = SEEK_SET;
        rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);
        if (state) {
            rb_io_close(arg.io);
            rb_jump_tag(state);
        }
    }
    return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);
}
            </pre> 
            </div><!-- binread-source -->
            
          </div>

          

          
        </div><!-- binread-method -->
      
        <div id="binwrite-method" class="method-detail ">
          <a name="method-c-binwrite"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">binwrite(name, string, [offset] )             &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">binwrite(name, string, [offset], open_args )  &rarr; integer</span>
            
          </div>
          
          
          <div>
  
            
            <p>Same as <a href="IO.html#method-c-write">::write</a> except opening the
file in binary mode and ASCII-8BIT encoding
(<code>&quot;wb:ASCII-8BIT&quot;</code>).</p>
            

            
            <div class="method-source-code" id="binwrite-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_binwrite(int argc, VALUE *argv, VALUE io)
{
    return io_s_write(argc, argv, io, 1);
}
            </pre> 
            </div><!-- binwrite-source -->
            
          </div>

          

          
        </div><!-- binwrite-method -->
      
        <div id="copy_stream-method" class="method-detail ">
          <a name="method-c-copy_stream"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">copy_stream(src, dst)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">copy_stream(src, dst, copy_length)</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">copy_stream(src, dst, copy_length, src_offset)</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="IO.html#method-c-copy_stream">::copy_stream</a> copies
<em>src</em> to <em>dst</em>. <em>src</em> and <em>dst</em> is either a
filename or an IO-like object. IO-like object for <em>src</em> should have
<a href="IO.html#method-i-readpartial">readpartial</a> or <a
href="IO.html#method-i-read">read</a> method.  IO-like object for
<em>dst</em> should have <a href="IO.html#method-i-write">write</a> method.
(Specialized mechanisms, such as sendfile system call, may be used on
appropriate situation.)</p>

<p>This method returns the number of bytes copied.</p>

<p>If optional arguments are not given, the start position of the copy is the
beginning of the filename or the current file offset of the <a
href="IO.html">IO</a>. The end position of the copy is the end of file.</p>

<p>If <em>copy_length</em> is given, No more than <em>copy_length</em> bytes
are copied.</p>

<p>If <em>src_offset</em> is given, it specifies the start position of the
copy.</p>

<p>When <em>src_offset</em> is specified and <em>src</em> is an <a
href="IO.html">IO</a>, <a
href="IO.html#method-c-copy_stream">::copy_stream</a> doesn&#39;t move the
current file offset.</p>
            

            
            <div class="method-source-code" id="copy_stream-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_copy_stream(int argc, VALUE *argv, VALUE io)
{
    VALUE src, dst, length, src_offset;
    struct copy_stream_struct st;

    MEMZERO(&amp;st, struct copy_stream_struct, 1);

    rb_scan_args(argc, argv, &quot;22&quot;, &amp;src, &amp;dst, &amp;length, &amp;src_offset);

    st.src = src;
    st.dst = dst;

    if (NIL_P(length))
        st.copy_length = (off_t)-1;
    else
        st.copy_length = NUM2OFFT(length);

    if (NIL_P(src_offset))
        st.src_offset = (off_t)-1;
    else
        st.src_offset = NUM2OFFT(src_offset);

    rb_ensure(copy_stream_body, (VALUE)&amp;st, copy_stream_finalize, (VALUE)&amp;st);

    return OFFT2NUM(st.total);
}
            </pre> 
            </div><!-- copy_stream-source -->
            
          </div>

          

          
        </div><!-- copy_stream-method -->
      
        <div id="for_fd-method" class="method-detail ">
          <a name="method-c-for_fd"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">for_fd(fd, mode [, opt])    &rarr; io</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Synonym for <a href="IO.html#method-c-new">::new</a>.</p>
            

            
            <div class="method-source-code" id="for_fd-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_for_fd(int argc, VALUE *argv, VALUE klass)
{
    VALUE io = rb_obj_alloc(klass);
    rb_io_initialize(argc, argv, io);
    return io;
}
            </pre> 
            </div><!-- for_fd-source -->
            
          </div>

          

          
        </div><!-- for_fd-method -->
      
        <div id="foreach-method" class="method-detail ">
          <a name="method-c-foreach"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">foreach(name, sep=$/ [, getline_args, open_args]) {|line| block }     &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">foreach(name, limit [, getline_args, open_args]) {|line| block }      &rarr; nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">foreach(name, sep, limit [, getline_args, open_args]) {|line| block } &rarr; nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">foreach(...)                                            &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Executes the block for every line in the named I/O port, where lines are
separated by <em>sep</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">foreach</span>(<span class="ruby-string">&quot;testfile&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;GOT &quot;</span>, <span class="ruby-identifier">x</span> }
</pre>

<p><em>produces:</em></p>

<pre>GOT This is line one
GOT This is line two
GOT This is line three
GOT And so on...</pre>

<p>If the last argument is a hash, it&#39;s the keyword argument to open. See
<a href="IO.html#method-c-readlines">::readlines</a> for details about
getline_args. And see also <a href="IO.html#method-c-read">::read</a> for
details about open_args.</p>
            

            
            <div class="method-source-code" id="foreach-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_foreach(int argc, VALUE *argv, VALUE self)
{
    VALUE opt;
    int orig_argc = argc;
    struct foreach_arg arg;
    struct getline_arg garg;

    argc = rb_scan_args(argc, argv, &quot;13:&quot;, NULL, NULL, NULL, NULL, &amp;opt);
    RETURN_ENUMERATOR(self, orig_argc, argv);
    extract_getline_args(argc-1, argv+1, &amp;garg);
    open_key_args(self, argc, argv, opt, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    extract_getline_opts(opt, &amp;garg);
    check_getline_args(&amp;garg.rs, &amp;garg.limit, garg.io = arg.io);
    return rb_ensure(io_s_foreach, (VALUE)&amp;garg, rb_io_close, arg.io);
}
            </pre> 
            </div><!-- foreach-source -->
            
          </div>

          

          
        </div><!-- foreach-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(fd [, mode] [, opt])   &rarr; io</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new <a href="IO.html">IO</a> object (a stream) for the given
integer file descriptor <code>fd</code> and <code>mode</code> string. 
<code>opt</code> may be used to specify parts of <code>mode</code> in a
more readable fashion.  See also <a
href="IO.html#method-c-sysopen">::sysopen</a> and <a
href="IO.html#method-c-for_fd">::for_fd</a>.</p>

<p><a href="IO.html#method-c-new">::new</a> is called by various <a
href="File.html">File</a> and <a href="IO.html">IO</a> opening methods such
as <a href="IO.html#method-c-open">::open</a>, <a
href="Kernel.html#method-i-open">Kernel#open</a>, and <a
href="File.html#method-c-open">File.open</a>.</p>

<h3 id="method-c-new-label-Open+Mode">Open Mode<span><a href="#method-c-new-label-Open+Mode">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When <code>mode</code> is an integer it must be combination of the modes
defined in <a href="File/Constants.html">File::Constants</a>
(<code>File::RDONLY</code>, <code>File::WRONLY|File::CREAT</code>). See the
open(2) man page for more information.</p>

<p>When <code>mode</code> is a string it must be in one of the following
forms:</p>

<pre>fmode
fmode &quot;:&quot; ext_enc
fmode &quot;:&quot; ext_enc &quot;:&quot; int_enc
fmode &quot;:&quot; &quot;BOM|UTF-*&quot;</pre>

<p><code>fmode</code> is an <a href="IO.html">IO</a> open mode string,
<code>ext_enc</code> is the external encoding for the <a
href="IO.html">IO</a> and <code>int_enc</code> is the internal encoding.</p>

<h4 id="method-c-new-label-IO+Open+Mode"><a href="IO.html">IO</a> Open Mode<span><a href="#method-c-new-label-IO+Open+Mode">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Ruby allows the following open modes:</p>

<pre>&quot;r&quot;  Read-only, starts at beginning of file  (default mode).

&quot;r+&quot; Read-write, starts at beginning of file.

&quot;w&quot;  Write-only, truncates existing file
     to zero length or creates a new file for writing.

&quot;w+&quot; Read-write, truncates existing file to zero length
     or creates a new file for reading and writing.

&quot;a&quot;  Write-only, each write call appends data at end of file.
     Creates a new file for writing if file does not exist.

&quot;a+&quot; Read-write, each write call appends data at end of file.
     Creates a new file for reading and writing if file does
     not exist.</pre>

<p>The following modes must be used separately, and along with one or more of
the modes seen above.</p>

<pre>&quot;b&quot;  Binary file mode
     Suppresses EOL &lt;-&gt; CRLF conversion on Windows. And
     sets external encoding to ASCII-8BIT unless explicitly
     specified.

&quot;t&quot;  Text file mode</pre>

<p>The exclusive access mode (“x”) can be used together with “w” to ensure the
file is created. Errno::EEXIST is raised when it already exists. It may not
be supported with all kinds of streams (e.g. pipes).</p>

<p>When the open mode of original <a href="IO.html">IO</a> is read only, the
mode cannot be changed to be writable.  Similarly, the open mode cannot be
changed from write only to readable.</p>

<p>When such a change is attempted the error is raised in different locations
according to the platform.</p>

<h3 id="method-c-new-label-IO+Encoding"><a href="IO.html">IO</a> <a href="Encoding.html">Encoding</a><span><a href="#method-c-new-label-IO+Encoding">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When <code>ext_enc</code> is specified, strings read will be tagged by the
encoding when reading, and strings output will be converted to the
specified encoding when writing.</p>

<p>When <code>ext_enc</code> and <code>int_enc</code> are specified read
strings will be converted from <code>ext_enc</code> to <code>int_enc</code>
upon input, and written strings will be converted from <code>int_enc</code>
to <code>ext_enc</code> upon output.  See <a
href="Encoding.html">Encoding</a> for further details of transcoding on
input and output.</p>

<p>If “BOM|UTF-8”, “BOM|UTF-16LE” or “BOM|UTF16-BE” are used, Ruby checks for
a Unicode BOM in the input document to help determine the encoding.  For
UTF-16 encodings the file open mode must be binary.  When present, the BOM
is stripped and the external encoding from the BOM is used.  When the BOM
is missing the given Unicode encoding is used as <code>ext_enc</code>. 
(The BOM-set encoding option is case insensitive, so “bom|utf-8” is also
valid.)</p>

<h3 id="method-c-new-label-Options">Options<span><a href="#method-c-new-label-Options">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><code>opt</code> can be used instead of <code>mode</code> for improved
readability.  The following keys are supported:</p>
<dl class="rdoc-list note-list"><dt>:mode 
<dd>
<p>Same as <code>mode</code> parameter</p>
</dd><dt>:flags 
<dd>
<p>Specifies file open flags as integer. If <code>mode</code> parameter is
given, this parameter will be bitwise-ORed.</p>
</dd><dt>:external_encoding 
<dd>
<p>External encoding for the <a href="IO.html">IO</a>.</p>
</dd><dt>:internal_encoding 
<dd>
<p>Internal encoding for the <a href="IO.html">IO</a>.  “-” is a synonym for
the default internal encoding.</p>

<p>If the value is <code>nil</code> no conversion occurs.</p>
</dd><dt>:encoding 
<dd>
<p>Specifies external and internal encodings as “extern:intern”.</p>
</dd><dt>:textmode 
<dd>
<p>If the value is truth value, same as “t” in argument <code>mode</code>.</p>
</dd><dt>:binmode 
<dd>
<p>If the value is truth value, same as “b” in argument <code>mode</code>.</p>
</dd><dt>:autoclose 
<dd>
<p>If the value is <code>false</code>, the <code>fd</code> will be kept open
after this <a href="IO.html">IO</a> instance gets finalized.</p>
</dd></dl>

<p>Also, <code>opt</code> can have same keys in <a
href="String.html#method-i-encode">String#encode</a> for controlling
conversion between the external encoding and the internal encoding.</p>

<h3 id="method-c-new-label-Example+1">Example 1<span><a href="#method-c-new-label-Example+1">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">fd</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">sysopen</span>(<span class="ruby-string">&quot;/dev/tty&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>)
<span class="ruby-identifier">a</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">fd</span>,<span class="ruby-string">&quot;w&quot;</span>)
<span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Hello&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;World&quot;</span>
</pre>

<p>Produces:</p>

<pre class="ruby"><span class="ruby-constant">Hello</span>
<span class="ruby-constant">World</span>
</pre>

<h3 id="method-c-new-label-Example+2">Example 2<span><a href="#method-c-new-label-Example+2">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;fcntl&#39;</span>

<span class="ruby-identifier">fd</span> = <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">fcntl</span>(<span class="ruby-constant">Fcntl</span><span class="ruby-operator">::</span><span class="ruby-constant">F_DUPFD</span>)
<span class="ruby-identifier">io</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">fd</span>, <span class="ruby-identifier">mode</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;w:UTF-16LE&#39;</span>, <span class="ruby-identifier">cr_newline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">io</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Hello, World!&quot;</span>

<span class="ruby-identifier">fd</span> = <span class="ruby-constant">STDERR</span>.<span class="ruby-identifier">fcntl</span>(<span class="ruby-constant">Fcntl</span><span class="ruby-operator">::</span><span class="ruby-constant">F_DUPFD</span>)
<span class="ruby-identifier">io</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">fd</span>, <span class="ruby-identifier">mode</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;w&#39;</span>, <span class="ruby-identifier">cr_newline</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>,
            <span class="ruby-identifier">external_encoding</span><span class="ruby-operator">:</span> <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">UTF_16LE</span>)
<span class="ruby-identifier">io</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Hello, World!&quot;</span>
</pre>

<p>Both of above print “Hello, World!” in UTF-16LE to standard error output
with converting EOL generated by <a href="IO.html#method-i-puts">puts</a>
to CR.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_initialize(int argc, VALUE *argv, VALUE io)
{
    VALUE fnum, vmode;
    rb_io_t *fp;
    int fd, fmode, oflags = O_RDONLY;
    convconfig_t convconfig;
    VALUE opt;
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    int ofmode;
#else
    struct stat st;
#endif


    argc = rb_scan_args(argc, argv, &quot;11:&quot;, &amp;fnum, &amp;vmode, &amp;opt);
    rb_io_extract_modeenc(&amp;vmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

    fd = NUM2INT(fnum);
    if (rb_reserved_fd_p(fd)) {
        rb_raise(rb_eArgError, &quot;The given fd is not accessible because RubyVM reserves it&quot;);
    }
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    oflags = fcntl(fd, F_GETFL);
    if (oflags == -1) rb_sys_fail(0);
#else
    if (fstat(fd, &amp;st) &lt; 0) rb_sys_fail(0);
#endif
    rb_update_max_fd(fd);
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    ofmode = rb_io_oflags_fmode(oflags);
    if (NIL_P(vmode)) {
        fmode = ofmode;
    }
    else if ((~ofmode &amp; fmode) &amp; FMODE_READWRITE) {
        VALUE error = INT2FIX(EINVAL);
        rb_exc_raise(rb_class_new_instance(1, &amp;error, rb_eSystemCallError));
    }
#endif
    if (!NIL_P(opt) &amp;&amp; rb_hash_aref(opt, sym_autoclose) == Qfalse) {
        fmode |= FMODE_PREP;
    }
    MakeOpenFile(io, fp);
    fp-&gt;fd = fd;
    fp-&gt;mode = fmode;
    fp-&gt;encs = convconfig;
    clear_codeconv(fp);
    io_check_tty(fp);
    if (fileno(stdin) == fd)
        fp-&gt;stdio_file = stdin;
    else if (fileno(stdout) == fd)
        fp-&gt;stdio_file = stdout;
    else if (fileno(stderr) == fd)
        fp-&gt;stdio_file = stderr;

    if (fmode &amp; FMODE_SETENC_BY_BOM) io_set_encoding_by_bom(io);
    return io;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="open-method" class="method-detail ">
          <a name="method-c-open"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">open(fd, mode="r" [, opt])                &rarr; io</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">open(fd, mode="r" [, opt]) {|io| block }  &rarr; obj</span>
            
          </div>
          
          
          <div>
  
            
            <p>With no associated block, <a href="IO.html#method-c-open">::open</a> is a
synonym for <a href="IO.html#method-c-new">::new</a>.  If the optional code
block is given, it will be passed <code>io</code> as an argument, and the
<a href="IO.html">IO</a> object will automatically be closed when the block
terminates. In this instance, <a href="IO.html#method-c-open">::open</a>
returns the value of the block.</p>

<p>See <a href="IO.html#method-c-new">::new</a> for a description of the
<code>fd</code>, <code>mode</code> and <code>opt</code> parameters.</p>
            

            
            <div class="method-source-code" id="open-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_open(int argc, VALUE *argv, VALUE klass)
{
    VALUE io = rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);

    if (rb_block_given_p()) {
        return rb_ensure(rb_yield, io, io_close, io);
    }

    return io;
}
            </pre> 
            </div><!-- open-source -->
            
          </div>

          

          
        </div><!-- open-method -->
      
        <div id="pipe-method" class="method-detail ">
          <a name="method-c-pipe"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pipe                             &rarr;  [read_io, write_io]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">pipe(ext_enc)                    &rarr;  [read_io, write_io]</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">pipe("ext_enc:int_enc" [, opt])  &rarr;  [read_io, write_io]</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">pipe(ext_enc, int_enc [, opt])   &rarr;  [read_io, write_io]</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">pipe(...) {|read_io, write_io| ... }</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a pair of pipe endpoints (connected to each other) and returns them
as a two-element array of <a href="IO.html">IO</a> objects: <code>[</code>
<em>read_io</em>, <em>write_io</em> <code>]</code>.</p>

<p>If a block is given, the block is called and returns the value of the
block. <em>read_io</em> and <em>write_io</em> are sent to the block as
arguments. If read_io and write_io are not closed when the block exits,
they are closed. i.e. closing read_io and/or write_io doesn&#39;t cause an
error.</p>

<p>Not available on all platforms.</p>

<p>If an encoding (encoding name or encoding object) is specified as an
optional argument, read string from pipe is tagged with the encoding
specified. If the argument is a colon separated two encoding names “A:B”,
the read string is converted from encoding A (external encoding) to
encoding B (internal encoding), then tagged with B. If two optional
arguments are specified, those must be encoding objects or encoding names,
and the first one is the external encoding, and the second one is the
internal encoding. If the external encoding and the internal encoding is
specified, optional hash argument specify the conversion option.</p>

<p>In the example below, the two processes close the ends of the pipe that
they are not using. This is not just a cosmetic nicety. The read end of a
pipe will not generate an end of file condition if there are any writers
with the pipe still open. In the case of the parent process, the
<code>rd.read</code> will never return if it does not first issue a
<code>wr.close</code>.</p>

<pre class="ruby"><span class="ruby-identifier">rd</span>, <span class="ruby-identifier">wr</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>

<span class="ruby-keyword">if</span> <span class="ruby-identifier">fork</span>
  <span class="ruby-identifier">wr</span>.<span class="ruby-identifier">close</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Parent got: &lt;#{rd.read}&gt;&quot;</span>
  <span class="ruby-identifier">rd</span>.<span class="ruby-identifier">close</span>
  <span class="ruby-constant">Process</span>.<span class="ruby-identifier">wait</span>
<span class="ruby-keyword">else</span>
  <span class="ruby-identifier">rd</span>.<span class="ruby-identifier">close</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Sending message to parent&quot;</span>
  <span class="ruby-identifier">wr</span>.<span class="ruby-identifier">write</span> <span class="ruby-string">&quot;Hi Dad&quot;</span>
  <span class="ruby-identifier">wr</span>.<span class="ruby-identifier">close</span>
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre>Sending message to parent
Parent got: &lt;Hi Dad&gt;</pre>
            

            
            <div class="method-source-code" id="pipe-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_pipe(int argc, VALUE *argv, VALUE klass)
{
    int pipes[2], state;
    VALUE r, w, args[3], v1, v2;
    VALUE opt;
    rb_io_t *fptr, *fptr2;
    struct io_encoding_set_args ies_args;
    int fmode = 0;
    VALUE ret;

    argc = rb_scan_args(argc, argv, &quot;02:&quot;, &amp;v1, &amp;v2, &amp;opt);
    if (rb_pipe(pipes) &lt; 0)
        rb_sys_fail(0);

    args[0] = klass;
    args[1] = INT2NUM(pipes[0]);
    args[2] = INT2FIX(O_RDONLY);
    r = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
        close(pipes[0]);
        close(pipes[1]);
        rb_jump_tag(state);
    }
    GetOpenFile(r, fptr);

    ies_args.fptr = fptr;
    ies_args.v1 = v1;
    ies_args.v2 = v2;
    ies_args.opt = opt;
    rb_protect(io_encoding_set_v, (VALUE)&amp;ies_args, &amp;state);
    if (state) {
        close(pipes[1]);
        io_close(r);
        rb_jump_tag(state);
    }

    args[1] = INT2NUM(pipes[1]);
    args[2] = INT2FIX(O_WRONLY);
    w = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
        close(pipes[1]);
        if (!NIL_P(r)) rb_io_close(r);
        rb_jump_tag(state);
    }
    GetOpenFile(w, fptr2);
    rb_io_synchronized(fptr2);

    extract_binmode(opt, &amp;fmode);

    if ((fmode &amp; FMODE_BINMODE) &amp;&amp; v1 == Qnil) {
        rb_io_ascii8bit_binmode(r);
        rb_io_ascii8bit_binmode(w);
    }

#if DEFAULT_TEXTMODE
    if ((fptr-&gt;mode &amp; FMODE_TEXTMODE) &amp;&amp; (fmode &amp; FMODE_BINMODE)) {
        fptr-&gt;mode &amp;= ~FMODE_TEXTMODE;
        setmode(fptr-&gt;fd, O_BINARY);
    }
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    if (fptr-&gt;encs.ecflags &amp; ECONV_DEFAULT_NEWLINE_DECORATOR) {
        fptr-&gt;encs.ecflags |= ECONV_UNIVERSAL_NEWLINE_DECORATOR;
    }
#endif
#endif
    fptr-&gt;mode |= fmode;
#if DEFAULT_TEXTMODE
    if ((fptr2-&gt;mode &amp; FMODE_TEXTMODE) &amp;&amp; (fmode &amp; FMODE_BINMODE)) {
        fptr2-&gt;mode &amp;= ~FMODE_TEXTMODE;
        setmode(fptr2-&gt;fd, O_BINARY);
    }
#endif
    fptr2-&gt;mode |= fmode;

    ret = rb_assoc_new(r, w);
    if (rb_block_given_p()) {
        VALUE rw[2];
        rw[0] = r;
        rw[1] = w;
        return rb_ensure(rb_yield, ret, pipe_pair_close, (VALUE)rw);
    }
    return ret;
}
            </pre> 
            </div><!-- pipe-source -->
            
          </div>

          

          
        </div><!-- pipe-method -->
      
        <div id="popen-method" class="method-detail ">
          <a name="method-c-popen"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">popen([env,] cmd, mode="r" [, opt])               &rarr; io</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">popen([env,] cmd, mode="r" [, opt]) {|io| block } &rarr; obj</span>
            
          </div>
          
          
          <div>
  
            
            <p>Runs the specified command as a subprocess; the subprocess&#39;s standard
input and output will be connected to the returned <a href="IO.html">IO</a>
object.</p>

<p>The PID of the started process can be obtained by <a
href="IO.html#method-i-pid">#pid</a> method.</p>

<p><em>cmd</em> is a string or an array as follows.</p>

<pre>cmd:
  &quot;-&quot;                                      : fork
  commandline                              : command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)
(env and opts are optional.)</pre>

<p>If <em>cmd</em> is a <code>String</code> “<code>-</code>&#39;&#39;, then a
new instance of Ruby is started as the subprocess.</p>

<p>If <em>cmd</em> is an <code>Array</code> of <code>String</code>, then it
will be used as the subprocess&#39;s <code>argv</code> bypassing a shell.
The array can contain a hash at first for environments and a hash at last
for options similar to <a href="Kernel.html#method-i-spawn">spawn</a>.</p>

<p>The default mode for the new file object is “r&#39;&#39;, but <em>mode</em>
may be set to any of the modes listed in the description for class <a
href="IO.html">IO</a>. The last argument <em>opt</em> qualifies
<em>mode</em>.</p>

<pre class="ruby"><span class="ruby-comment"># set IO encoding</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;nkf -e filename&quot;</span>, :<span class="ruby-identifier">external_encoding=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&quot;EUC-JP&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">nkf_io</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">euc_jp_string</span> = <span class="ruby-identifier">nkf_io</span>.<span class="ruby-identifier">read</span>
}

<span class="ruby-comment"># merge standard output and standard error using</span>
<span class="ruby-comment"># spawn option.  See the document of Kernel.spawn.</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>([<span class="ruby-string">&quot;ls&quot;</span>, <span class="ruby-string">&quot;/&quot;</span>, :<span class="ruby-identifier">err=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">child</span>, :<span class="ruby-identifier">out</span>]]) {<span class="ruby-operator">|</span><span class="ruby-identifier">ls_io</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">ls_result_with_error</span> = <span class="ruby-identifier">ls_io</span>.<span class="ruby-identifier">read</span>
}

<span class="ruby-comment"># spawn options can be mixed with IO options</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>([<span class="ruby-string">&quot;ls&quot;</span>, <span class="ruby-string">&quot;/&quot;</span>], :<span class="ruby-identifier">err=</span><span class="ruby-operator">&gt;</span>[:<span class="ruby-identifier">child</span>, :<span class="ruby-identifier">out</span>]) {<span class="ruby-operator">|</span><span class="ruby-identifier">ls_io</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">ls_result_with_error</span> = <span class="ruby-identifier">ls_io</span>.<span class="ruby-identifier">read</span>
}
</pre>

<p>Raises exceptions which <a href="IO.html#method-c-pipe">::pipe</a> and <a
href="Kernel.html#method-i-spawn">Kernel#spawn</a> raise.</p>

<p>If a block is given, Ruby will run the command as a child connected to Ruby
with a pipe. Ruby&#39;s end of the pipe will be passed as a parameter to
the block. At the end of block, Ruby closes the pipe and sets
<code>$?</code>. In this case <a href="IO.html#method-c-popen">::popen</a>
returns the value of the block.</p>

<p>If a block is given with a <em>cmd</em> of “<code>-</code>&#39;&#39;, the
block will be run in two separate processes: once in the parent, and once
in a child. The parent process will be passed the pipe object as a
parameter to the block, the child version of the block will be passed
<code>nil</code>, and the child&#39;s standard in and standard out will be
connected to the parent through the pipe. Not available on all platforms.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;uname&quot;</span>)
<span class="ruby-identifier">p</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">readlines</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Parent is #{Process.pid}&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;date&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span> }
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;-&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{Process.pid} is here, f is #{f.inspect}&quot;</span>}
<span class="ruby-identifier">p</span> <span class="ruby-identifier">$?</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-node">%w&quot;sed -e s|^|&lt;foo&gt;| -e s&amp;$&amp;;zot;&amp;&quot;</span>, <span class="ruby-string">&quot;r+&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;bar&quot;</span>; <span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_write</span>; <span class="ruby-identifier">puts</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>
}
</pre>

<p><em>produces:</em></p>

<pre>[&quot;Linux\n&quot;]
Parent is 21346
Thu Jan 15 22:41:19 JST 2009
21346 is here, f is #&lt;IO:fd 3&gt;
21352 is here, f is nil
#&lt;Process::Status: pid 21352 exit 0&gt;
&lt;foo&gt;bar;zot;</pre>
            

            
            <div class="method-source-code" id="popen-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_popen(int argc, VALUE *argv, VALUE klass)
{
    const char *modestr;
    VALUE pname, pmode = Qnil, port, tmp, opt = Qnil, env = Qnil, execarg_obj = Qnil;
    int oflags, fmode;
    convconfig_t convconfig;

    if (argc &gt; 1 &amp;&amp; !NIL_P(opt = rb_check_hash_type(argv[argc-1]))) --argc;
    if (argc &gt; 1 &amp;&amp; !NIL_P(env = rb_check_hash_type(argv[0]))) --argc, ++argv;
    switch (argc) {
      case 2:
        pmode = argv[1];
      case 1:
        pname = argv[0];
        break;
      default:
        {
            int ex = !NIL_P(opt);
            rb_error_arity(argc + ex, 1 + ex, 2 + ex);
        }
    }

    tmp = rb_check_array_type(pname);
    if (!NIL_P(tmp)) {
        long len = RARRAY_LEN(tmp);
#if SIZEOF_LONG &gt; SIZEOF_INT
        if (len &gt; INT_MAX) {
            rb_raise(rb_eArgError, &quot;too many arguments&quot;);
        }
#endif
        execarg_obj = rb_execarg_new((int)len, RARRAY_CONST_PTR(tmp), FALSE, FALSE);
        RB_GC_GUARD(tmp);
    }
    else {
        SafeStringValue(pname);
        execarg_obj = Qnil;
        if (!is_popen_fork(pname))
            execarg_obj = rb_execarg_new(1, &amp;pname, TRUE, FALSE);
    }
    if (!NIL_P(execarg_obj)) {
        if (!NIL_P(opt))
            opt = rb_execarg_extract_options(execarg_obj, opt);
        if (!NIL_P(env))
            rb_execarg_setenv(execarg_obj, env);
    }
    rb_io_extract_modeenc(&amp;pmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);
    modestr = rb_io_oflags_modestr(oflags);

    port = pipe_open(execarg_obj, modestr, fmode, &amp;convconfig);
    if (NIL_P(port)) {
        /* child */
        if (rb_block_given_p()) {
            rb_yield(Qnil);
            rb_io_flush(rb_stdout);
            rb_io_flush(rb_stderr);
            _exit(0);
        }
        return Qnil;
    }
    RBASIC_SET_CLASS(port, klass);
    if (rb_block_given_p()) {
        return rb_ensure(rb_yield, port, pipe_close, port);
    }
    return port;
}
            </pre> 
            </div><!-- popen-source -->
            
          </div>

          

          
        </div><!-- popen-method -->
      
        <div id="read-method" class="method-detail ">
          <a name="method-c-read"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">read(name, [length [, offset]] [, opt] )   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Opens the file, optionally seeks to the given <code>offset</code>, then
returns <code>length</code> bytes (defaulting to the rest of the file).  <a
href="IO.html#method-i-read">read</a> ensures the file is closed before
returning.</p>

<p>If <code>name</code> starts with a pipe character
(<code>&quot;|&quot;</code>), a subprocess is created in the same way as <a
href="Kernel.html#method-i-open">Kernel#open</a>, and its output is
returned.</p>

<h3 id="method-c-read-label-Options">Options<span><a href="#method-c-read-label-Options">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The options hash accepts the following keys:</p>
<dl class="rdoc-list note-list"><dt>:encoding
<dd>
<p>string or encoding</p>

<p>Specifies the encoding of the read string.  <code>:encoding</code> will be
ignored if <code>length</code> is specified.  See <a
href="Encoding.html#method-c-aliases">Encoding.aliases</a> for possible
encodings.</p>
</dd><dt>:mode
<dd>
<p>string or integer</p>

<p>Specifies the <em>mode</em> argument for open().  It must start with an
“r”, otherwise it will cause an error. See <a
href="IO.html#method-c-new">::new</a> for the list of possible modes.</p>
</dd><dt>:open_args
<dd>
<p>array</p>

<p>Specifies arguments for open() as an array.  This key can not be used in
combination with either <code>:encoding</code> or <code>:mode</code>.</p>
</dd></dl>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">read</span>(<span class="ruby-string">&quot;testfile&quot;</span>)              <span class="ruby-comment">#=&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">read</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-value">20</span>)          <span class="ruby-comment">#=&gt; &quot;This is line one\nThi&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">read</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-value">20</span>, <span class="ruby-value">10</span>)      <span class="ruby-comment">#=&gt; &quot;ne one\nThis is line &quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">read</span>(<span class="ruby-string">&quot;binfile&quot;</span>, <span class="ruby-identifier">mode</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;rb&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;\xF7\x00\x00\x0E\x12&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="read-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_read(int argc, VALUE *argv, VALUE io)
{
    VALUE opt, offset;
    struct foreach_arg arg;

    argc = rb_scan_args(argc, argv, &quot;13:&quot;, NULL, NULL, &amp;offset, NULL, &amp;opt);
    open_key_args(io, argc, argv, opt, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    if (!NIL_P(offset)) {
        struct seek_arg sarg;
        int state = 0;
        sarg.io = arg.io;
        sarg.offset = offset;
        sarg.mode = SEEK_SET;
        rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);
        if (state) {
            rb_io_close(arg.io);
            rb_jump_tag(state);
        }
        if (arg.argc == 2) arg.argc = 1;
    }
    return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);
}
            </pre> 
            </div><!-- read-source -->
            
          </div>

          

          
        </div><!-- read-method -->
      
        <div id="readlines-method" class="method-detail ">
          <a name="method-c-readlines"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readlines(name, sep=$/ [, getline_args, open_args])     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readlines(name, limit [, getline_args, open_args])      &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readlines(name, sep, limit [, getline_args, open_args]) &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads the entire file specified by <em>name</em> as individual lines, and
returns those lines in an array. Lines are separated by <em>sep</em>.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">readlines</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>

<span class="ruby-identifier">b</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">readlines</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-identifier">chomp</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">b</span>[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; &quot;This is line one&quot;</span>
</pre>

<p>If the last argument is a hash, it&#39;s the keyword argument to open.</p>

<h3 id="method-c-readlines-label-Options+for+getline">Options for getline<span><a href="#method-c-readlines-label-Options+for+getline">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The options hash accepts the following keys:</p>
<dl class="rdoc-list note-list"><dt>:chomp
<dd>
<p>When the optional <code>chomp</code> keyword argument has a true value,
<code>\n</code>, <code>\r</code>, and <code>\r\n</code> will be removed
from the end of each line.</p>
</dd></dl>

<p>See also <a href="IO.html#method-c-read">::read</a> for details about
open_args.</p>
            

            
            <div class="method-source-code" id="readlines-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_readlines(int argc, VALUE *argv, VALUE io)
{
    VALUE opt;
    struct foreach_arg arg;
    struct getline_arg garg;

    argc = rb_scan_args(argc, argv, &quot;13:&quot;, NULL, NULL, NULL, NULL, &amp;opt);
    extract_getline_args(argc-1, argv+1, &amp;garg);
    open_key_args(io, argc, argv, opt, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    extract_getline_opts(opt, &amp;garg);
    check_getline_args(&amp;garg.rs, &amp;garg.limit, garg.io = arg.io);
    return rb_ensure(io_s_readlines, (VALUE)&amp;garg, rb_io_close, arg.io);
}
            </pre> 
            </div><!-- readlines-source -->
            
          </div>

          

          
        </div><!-- readlines-method -->
      
        <div id="select-method" class="method-detail ">
          <a name="method-c-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select(read_array [, write_array [, error_array [, timeout]]]) &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls select(2) system call. It monitors given arrays of <a
href="IO.html">IO</a> objects, waits until one or more of <a
href="IO.html">IO</a> objects are ready for reading, are ready for writing,
and have pending exceptions respectively, and returns an array that
contains arrays of those <a href="IO.html">IO</a> objects.  It will return
<code>nil</code> if optional <em>timeout</em> value is given and no <a
href="IO.html">IO</a> object is ready in <em>timeout</em> seconds.</p>

<p><a href="IO.html#method-c-select">::select</a> peeks the buffer of <a
href="IO.html">IO</a> objects for testing readability. If the <a
href="IO.html">IO</a> buffer is not empty, <a
href="IO.html#method-c-select">::select</a> immediately notifies
readability.  This “peek” only happens for <a href="IO.html">IO</a>
objects.  It does not happen for IO-like objects such as
OpenSSL::SSL::SSLSocket.</p>

<p>The best way to use <a href="IO.html#method-c-select">::select</a> is
invoking it after nonblocking methods such as <a
href="IO.html#method-i-read_nonblock">read_nonblock</a>, <a
href="IO.html#method-i-write_nonblock">write_nonblock</a>, etc.  The
methods raise an exception which is extended by <a
href="IO/WaitReadable.html">IO::WaitReadable</a> or <a
href="IO/WaitWritable.html">IO::WaitWritable</a>.  The modules notify how
the caller should wait with <a href="IO.html#method-c-select">::select</a>.
If <a href="IO/WaitReadable.html">IO::WaitReadable</a> is raised, the
caller should wait for reading.  If <a
href="IO/WaitWritable.html">IO::WaitWritable</a> is raised, the caller
should wait for writing.</p>

<p>So, blocking read (#readpartial) can be emulated using <a
href="IO.html#method-i-read_nonblock">read_nonblock</a> and <a
href="IO.html#method-c-select">::select</a> as follows:</p>

<pre class="ruby"><span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">io_like</span>.<span class="ruby-identifier">read_nonblock</span>(<span class="ruby-identifier">maxlen</span>)
<span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitReadable</span>
  <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>([<span class="ruby-identifier">io_like</span>])
  <span class="ruby-keyword">retry</span>
<span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitWritable</span>
  <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>(<span class="ruby-keyword">nil</span>, [<span class="ruby-identifier">io_like</span>])
  <span class="ruby-keyword">retry</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Especially, the combination of nonblocking methods and <a
href="IO.html#method-c-select">::select</a> is preferred for <a
href="IO.html">IO</a> like objects such as OpenSSL::SSL::SSLSocket.  It has
<a href="IO.html#method-i-to_io">to_io</a> method to return underlying <a
href="IO.html">IO</a> object.  <a
href="IO.html#method-c-select">::select</a> calls <a
href="IO.html#method-i-to_io">to_io</a> to obtain the file descriptor to
wait.</p>

<p>This means that readability notified by <a
href="IO.html#method-c-select">::select</a> doesn&#39;t mean readability
from OpenSSL::SSL::SSLSocket object.</p>

<p>The most likely situation is that OpenSSL::SSL::SSLSocket buffers some
data.  <a href="IO.html#method-c-select">::select</a> doesn&#39;t see the
buffer.  So <a href="IO.html#method-c-select">::select</a> can block when
OpenSSL::SSL::SSLSocket#readpartial doesn&#39;t block.</p>

<p>However, several more complicated situations exist.</p>

<p>SSL is a protocol which is sequence of records. The record consists of
multiple bytes. So, the remote side of SSL sends a partial record, <a
href="IO.html#method-c-select">::select</a> notifies readability but
OpenSSL::SSL::SSLSocket cannot decrypt a byte and
OpenSSL::SSL::SSLSocket#readpartial will block.</p>

<p>Also, the remote side can request SSL renegotiation which forces the local
SSL engine to write some data. This means
OpenSSL::SSL::SSLSocket#readpartial may invoke <a
href="IO.html#method-i-write">write</a> system call and it can block. In
such a situation, OpenSSL::SSL::SSLSocket#read_nonblock raises <a
href="IO/WaitWritable.html">IO::WaitWritable</a> instead of blocking. So,
the caller should wait for ready for writability as above example.</p>

<p>The combination of nonblocking methods and <a
href="IO.html#method-c-select">::select</a> is also useful for streams such
as tty, pipe socket socket when multiple processes read from a stream.</p>

<p>Finally, Linux kernel developers don&#39;t guarantee that readability of
select(2) means readability of following read(2) even for a single process.
See select(2) manual on GNU/Linux system.</p>

<p>Invoking <a href="IO.html#method-c-select">::select</a> before <a
href="IO.html#method-i-readpartial">#readpartial</a> works well as usual.
However it is not the best way to use <a
href="IO.html#method-c-select">::select</a>.</p>

<p>The writability notified by select(2) doesn&#39;t show how many bytes are
writable. <a href="IO.html#method-i-write">#write</a> method blocks until
given whole string is written. So, <code>IO#write(two or more bytes)</code>
can block after writability is notified by <a
href="IO.html#method-c-select">::select</a>.  <a
href="IO.html#method-i-write_nonblock">#write_nonblock</a> is required to
avoid the blocking.</p>

<p>Blocking write (#write) can be emulated using <a
href="IO.html#method-i-write_nonblock">write_nonblock</a> and <a
href="IO.html#method-c-select">::select</a> as follows: <a
href="IO/WaitReadable.html">IO::WaitReadable</a> should also be rescued for
SSL renegotiation in OpenSSL::SSL::SSLSocket.</p>

<pre class="ruby"><span class="ruby-keyword">while</span> <span class="ruby-value">0</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">string</span>.<span class="ruby-identifier">bytesize</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">written</span> = <span class="ruby-identifier">io_like</span>.<span class="ruby-identifier">write_nonblock</span>(<span class="ruby-identifier">string</span>)
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitReadable</span>
    <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>([<span class="ruby-identifier">io_like</span>])
    <span class="ruby-keyword">retry</span>
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitWritable</span>
    <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>(<span class="ruby-keyword">nil</span>, [<span class="ruby-identifier">io_like</span>])
    <span class="ruby-keyword">retry</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">string</span> = <span class="ruby-identifier">string</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-identifier">written</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>)
<span class="ruby-keyword">end</span>
</pre>

<h3 id="method-c-select-label-Parameters">Parameters<span><a href="#method-c-select-label-Parameters">&para;</a> <a href="#top">&uarr;</a></span></h3>
<dl class="rdoc-list note-list"><dt>read_array
<dd>
<p>an array of <a href="IO.html">IO</a> objects that wait until ready for read</p>
</dd><dt>write_array
<dd>
<p>an array of <a href="IO.html">IO</a> objects that wait until ready for
write</p>
</dd><dt>error_array
<dd>
<p>an array of <a href="IO.html">IO</a> objects that wait for exceptions</p>
</dd><dt>timeout
<dd>
<p>a numeric value in second</p>
</dd></dl>

<h3 id="method-c-select-label-Example">Example<span><a href="#method-c-select-label-Example">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">rp</span>, <span class="ruby-identifier">wp</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>
<span class="ruby-identifier">mesg</span> = <span class="ruby-string">&quot;ping &quot;</span>
<span class="ruby-value">100</span>.<span class="ruby-identifier">times</span> {
  <span class="ruby-comment"># IO.select follows IO#read.  Not the best way to use IO.select.</span>
  <span class="ruby-identifier">rs</span>, <span class="ruby-identifier">ws</span>, = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>([<span class="ruby-identifier">rp</span>], [<span class="ruby-identifier">wp</span>])
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span> = <span class="ruby-identifier">rs</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">ret</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">5</span>)
    <span class="ruby-identifier">print</span> <span class="ruby-identifier">ret</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">ret</span>
    <span class="ruby-keyword">when</span> <span class="ruby-regexp">/ping/</span>
      <span class="ruby-identifier">mesg</span> = <span class="ruby-string">&quot;pong\n&quot;</span>
    <span class="ruby-keyword">when</span> <span class="ruby-regexp">/pong/</span>
      <span class="ruby-identifier">mesg</span> = <span class="ruby-string">&quot;ping &quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">w</span> = <span class="ruby-identifier">ws</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">w</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">mesg</span>)
  <span class="ruby-keyword">end</span>
}
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-identifier">ping</span> <span class="ruby-identifier">pong</span>
<span class="ruby-identifier">ping</span> <span class="ruby-identifier">pong</span>
<span class="ruby-identifier">ping</span> <span class="ruby-identifier">pong</span>
(<span class="ruby-identifier">snipped</span>)
<span class="ruby-identifier">ping</span>
</pre>
            

            
            <div class="method-source-code" id="select-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_f_select(int argc, VALUE *argv, VALUE obj)
{
    VALUE timeout;
    struct select_args args;
    struct timeval timerec;
    int i;

    rb_scan_args(argc, argv, &quot;13&quot;, &amp;args.read, &amp;args.write, &amp;args.except, &amp;timeout);
    if (NIL_P(timeout)) {
        args.timeout = 0;
    }
    else {
        timerec = rb_time_interval(timeout);
        args.timeout = &amp;timerec;
    }

    for (i = 0; i &lt; numberof(args.fdsets); ++i)
        rb_fd_init(&amp;args.fdsets[i]);

    return rb_ensure(select_call, (VALUE)&amp;args, select_end, (VALUE)&amp;args);
}
            </pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->
      
        <div id="sysopen-method" class="method-detail ">
          <a name="method-c-sysopen"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sysopen(path, [mode, [perm]])  &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Opens the given path, returning the underlying file descriptor as a <a
href="Integer.html">Integer</a>.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">sysopen</span>(<span class="ruby-string">&quot;testfile&quot;</span>)   <span class="ruby-comment">#=&gt; 3</span>
</pre>
            

            
            <div class="method-source-code" id="sysopen-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_sysopen(int argc, VALUE *argv, VALUE _)
{
    VALUE fname, vmode, vperm;
    VALUE intmode;
    int oflags, fd;
    mode_t perm;

    rb_scan_args(argc, argv, &quot;12&quot;, &amp;fname, &amp;vmode, &amp;vperm);
    FilePathValue(fname);

    if (NIL_P(vmode))
        oflags = O_RDONLY;
    else if (!NIL_P(intmode = rb_check_to_integer(vmode, &quot;to_int&quot;)))
        oflags = NUM2INT(intmode);
    else {
        SafeStringValue(vmode);
        oflags = rb_io_modestr_oflags(StringValueCStr(vmode));
    }
    if (NIL_P(vperm)) perm = 0666;
    else              perm = NUM2MODET(vperm);

    RB_GC_GUARD(fname) = rb_str_new4(fname);
    fd = rb_sysopen(fname, oflags, perm);
    return INT2NUM(fd);
}
            </pre> 
            </div><!-- sysopen-source -->
            
          </div>

          

          
        </div><!-- sysopen-method -->
      
        <div id="try_convert-method" class="method-detail ">
          <a name="method-c-try_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">try_convert(obj)  &rarr; io or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Try to convert <em>obj</em> into an <a href="IO.html">IO</a>, using <a
href="IO.html#method-i-to_io">#to_io</a> method. Returns converted <a
href="IO.html">IO</a> or <code>nil</code> if <em>obj</em> cannot be
converted for any reason.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-constant">STDOUT</span>)     <span class="ruby-comment">#=&gt; STDOUT</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-string">&quot;STDOUT&quot;</span>)   <span class="ruby-comment">#=&gt; nil</span>

<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;zlib&#39;</span>
<span class="ruby-identifier">f</span> = <span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/tmp/zz.gz&quot;</span>)       <span class="ruby-comment">#=&gt; #&lt;File:/tmp/zz.gz&gt;</span>
<span class="ruby-identifier">z</span> = <span class="ruby-constant">Zlib</span><span class="ruby-operator">::</span><span class="ruby-constant">GzipReader</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">f</span>) <span class="ruby-comment">#=&gt; #&lt;Zlib::GzipReader:0x81d8744&gt;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-identifier">z</span>)            <span class="ruby-comment">#=&gt; #&lt;File:/tmp/zz.gz&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="try_convert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_try_convert(VALUE dummy, VALUE io)
{
    return rb_io_check_io(io);
}
            </pre> 
            </div><!-- try_convert-source -->
            
          </div>

          

          
        </div><!-- try_convert-method -->
      
        <div id="write-method" class="method-detail ">
          <a name="method-c-write"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">write(name, string [, offset])           &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">write(name, string [, offset] [, opt])   &rarr; integer</span>
            
          </div>
          
          
          <div>
  
            
            <p>Opens the file, optionally seeks to the given <em>offset</em>, writes
<em>string</em>, then returns the length written.  <a
href="IO.html#method-i-write">write</a> ensures the file is closed before
returning.  If <em>offset</em> is not given in write mode, the file is
truncated.  Otherwise, it is not truncated.</p>

<pre class="ruby"><span class="ruby-constant">IO</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;0123456789&quot;</span>, <span class="ruby-value">20</span>)  <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-comment"># File could contain:  &quot;This is line one\nThi0123456789two\nThis is line three\nAnd so on...\n&quot;</span>
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;0123456789&quot;</span>)      <span class="ruby-comment">#=&gt; 10</span>
<span class="ruby-comment"># File would now read: &quot;0123456789&quot;</span>
</pre>

<p>If the last argument is a hash, it specifies options for the internal
open().  It accepts the following keys:</p>
<dl class="rdoc-list note-list"><dt>:encoding
<dd>
<p>string or encoding</p>

<p>Specifies the encoding of the read string. See <a
href="Encoding.html#method-c-aliases">Encoding.aliases</a> for possible
encodings.</p>
</dd><dt>:mode
<dd>
<p>string or integer</p>

<p>Specifies the <em>mode</em> argument for open().  It must start with “w”,
“a”, or “r+”, otherwise it will cause an error. See <a
href="IO.html#method-c-new">::new</a> for the list of possible modes.</p>
</dd><dt>:perm
<dd>
<p>integer</p>

<p>Specifies the <em>perm</em> argument for open().</p>
</dd><dt>:open_args
<dd>
<p>array</p>

<p>Specifies arguments for open() as an array. This key can not be used in
combination with other keys.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="write-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_s_write(int argc, VALUE *argv, VALUE io)
{
    return io_s_write(argc, argv, io, 0);
}
            </pre> 
            </div><!-- write-source -->
            
          </div>

          

          
        </div><!-- write-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3C-3C-method" class="method-detail ">
          <a name="method-i-3C-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ios << obj     &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="String.html">String</a> Output—Writes <em>obj</em> to
<em>ios</em>. <em>obj</em> will be converted to a string using
<code>to_s</code>.</p>

<pre class="ruby"><span class="ruby-identifier">$stdout</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;Hello &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;world!\n&quot;</span>
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-constant">Hello</span> <span class="ruby-identifier">world!</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3C-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_addstr(VALUE io, VALUE str)
{
    rb_io_write(io, str);
    return io;
}
            </pre> 
            </div><!-- 3C-3C-source -->
            
          </div>

          

          
        </div><!-- 3C-3C-method -->
      
        <div id="advise-method" class="method-detail ">
          <a name="method-i-advise"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">advise(advice, offset=0, len=0) &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Announce an intention to access data from the current file in a specific
pattern. On platforms that do not support the <em>posix_fadvise(2)</em>
system call, this method is a no-op.</p>

<p><em>advice</em> is one of the following symbols:</p>
<dl class="rdoc-list note-list"><dt>:normal
<dd>
<p>No advice to give; the default assumption for an open file.</p>
</dd><dt>:sequential
<dd>
<p>The data will be accessed sequentially with lower offsets read before
higher ones.</p>
</dd><dt>:random
<dd>
<p>The data will be accessed in random order.</p>
</dd><dt>:willneed
<dd>
<p>The data will be accessed in the near future.</p>
</dd><dt>:dontneed
<dd>
<p>The data will not be accessed in the near future.</p>
</dd><dt>:noreuse
<dd>
<p>The data will only be accessed once.</p>
</dd></dl>

<p>The semantics of a piece of advice are platform-dependent. See <em>man 2
posix_fadvise</em> for details.</p>

<p>“data” means the region of the current file that begins at <em>offset</em>
and extends for <em>len</em> bytes. If <em>len</em> is 0, the region ends
at the last byte of the file. By default, both <em>offset</em> and
<em>len</em> are 0, meaning that the advice applies to the entire file.</p>

<p>If an error occurs, one of the following exceptions will be raised:</p>
<dl class="rdoc-list note-list"><dt><a href="IOError.html">IOError</a>
<dd>
<p>The <a href="IO.html">IO</a> stream is closed.</p>
</dd><dt>Errno::EBADF
<dd>
<p>The file descriptor of the current file is invalid.</p>
</dd><dt>Errno::EINVAL
<dd>
<p>An invalid value for <em>advice</em> was given.</p>
</dd><dt>Errno::ESPIPE
<dd>
<p>The file descriptor of the current file refers to a FIFO or pipe. (Linux
raises Errno::EINVAL in this case).</p>
</dd><dt><a href="TypeError.html">TypeError</a>
<dd>
<p>Either <em>advice</em> was not a <a href="Symbol.html">Symbol</a>, or one
of the other arguments was not an <a href="Integer.html">Integer</a>.</p>
</dd><dt><a href="RangeError.html">RangeError</a>
<dd>
<p>One of the arguments given was too big/small.</p>
</dd><dt>This list is not exhaustive; other <a href="Errno.html">Errno</a>
<dd>
<p>exceptions are also possible.</p>
</dd></dl>
            

            
            <div class="method-source-code" id="advise-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_advise(int argc, VALUE *argv, VALUE io)
{
    VALUE advice, offset, len;
    off_t off, l;
    rb_io_t *fptr;

    rb_scan_args(argc, argv, &quot;12&quot;, &amp;advice, &amp;offset, &amp;len);
    advice_arg_check(advice);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    off = NIL_P(offset) ? 0 : NUM2OFFT(offset);
    l   = NIL_P(len)    ? 0 : NUM2OFFT(len);

#ifdef HAVE_POSIX_FADVISE
    return do_io_advise(fptr, advice, off, l);
#else
    ((void)off, (void)l);       /* Ignore all hint */
    return Qnil;
#endif
}
            </pre> 
            </div><!-- advise-source -->
            
          </div>

          

          
        </div><!-- advise-method -->
      
        <div id="autoclose-3D-method" class="method-detail ">
          <a name="method-i-autoclose-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">autoclose = bool    &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets auto-close flag.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/dev/null&quot;</span>)
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">for_fd</span>(<span class="ruby-identifier">f</span>.<span class="ruby-identifier">fileno</span>)
<span class="ruby-comment"># ...</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span> <span class="ruby-comment"># may cause Errno::EBADF</span>

<span class="ruby-identifier">f</span> = <span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/dev/null&quot;</span>)
<span class="ruby-constant">IO</span>.<span class="ruby-identifier">for_fd</span>(<span class="ruby-identifier">f</span>.<span class="ruby-identifier">fileno</span>).<span class="ruby-identifier">autoclose</span> = <span class="ruby-keyword">false</span>
<span class="ruby-comment"># ...</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span> <span class="ruby-comment"># won&#39;t cause Errno::EBADF</span>
</pre>
            

            
            <div class="method-source-code" id="autoclose-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_set_autoclose(VALUE io, VALUE autoclose)
{
    rb_io_t *fptr;
    GetOpenFile(io, fptr);
    if (!RTEST(autoclose))
        fptr-&gt;mode |= FMODE_PREP;
    else
        fptr-&gt;mode &amp;= ~FMODE_PREP;
    return autoclose;
}
            </pre> 
            </div><!-- autoclose-3D-source -->
            
          </div>

          

          
        </div><!-- autoclose-3D-method -->
      
        <div id="autoclose-3F-method" class="method-detail ">
          <a name="method-i-autoclose-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">autoclose?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if the underlying file descriptor of <em>ios</em>
will be closed automatically at its finalization, otherwise
<code>false</code>.</p>
            

            
            <div class="method-source-code" id="autoclose-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_autoclose_p(VALUE io)
{
    rb_io_t *fptr = RFILE(io)-&gt;fptr;
    rb_io_check_closed(fptr);
    return (fptr-&gt;mode &amp; FMODE_PREP) ? Qfalse : Qtrue;
}
            </pre> 
            </div><!-- autoclose-3F-source -->
            
          </div>

          

          
        </div><!-- autoclose-3F-method -->
      
        <div id="binmode-method" class="method-detail ">
          <a name="method-i-binmode"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">binmode    &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Puts <em>ios</em> into binary mode. Once a stream is in binary mode, it
cannot be reset to nonbinary mode.</p>
<ul><li>
<p>newline conversion disabled</p>
</li><li>
<p>encoding conversion disabled</p>
</li><li>
<p>content is treated as ASCII-8BIT</p>
</li></ul>
            

            
            <div class="method-source-code" id="binmode-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_binmode_m(VALUE io)
{
    VALUE write_io;

    rb_io_ascii8bit_binmode(io);

    write_io = GetWriteIO(io);
    if (write_io != io)
        rb_io_ascii8bit_binmode(write_io);
    return io;
}
            </pre> 
            </div><!-- binmode-source -->
            
          </div>

          

          
        </div><!-- binmode-method -->
      
        <div id="binmode-3F-method" class="method-detail ">
          <a name="method-i-binmode-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">binmode?    &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>ios</em> is binmode.</p>
            

            
            <div class="method-source-code" id="binmode-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_binmode_p(VALUE io)
{
    rb_io_t *fptr;
    GetOpenFile(io, fptr);
    return fptr-&gt;mode &amp; FMODE_BINMODE ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- binmode-3F-source -->
            
          </div>

          

          
        </div><!-- binmode-3F-method -->
      
        <div id="bytes-method" class="method-detail ">
          <a name="method-i-bytes"></a>

          
          <div class="method-heading">
            <span class="method-name">bytes</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>This is a deprecated alias for <a
href="IO.html#method-i-each_byte">each_byte</a>.</p>
            

            
            <div class="method-source-code" id="bytes-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_bytes(VALUE io)
{
    rb_warn_deprecated(&quot;IO#bytes&quot;, &quot;#each_byte&quot;);
    if (!rb_block_given_p())
        return rb_enumeratorize(io, ID2SYM(rb_intern(&quot;each_byte&quot;)), 0, 0);
    return rb_io_each_byte(io);
}
            </pre> 
            </div><!-- bytes-source -->
            
          </div>

          

          
        </div><!-- bytes-method -->
      
        <div id="chars-method" class="method-detail ">
          <a name="method-i-chars"></a>

          
          <div class="method-heading">
            <span class="method-name">chars</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>This is a deprecated alias for <a
href="IO.html#method-i-each_char">each_char</a>.</p>
            

            
            <div class="method-source-code" id="chars-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_chars(VALUE io)
{
    rb_warn_deprecated(&quot;IO#chars&quot;, &quot;#each_char&quot;);
    if (!rb_block_given_p())
        return rb_enumeratorize(io, ID2SYM(rb_intern(&quot;each_char&quot;)), 0, 0);
    return rb_io_each_char(io);
}
            </pre> 
            </div><!-- chars-source -->
            
          </div>

          

          
        </div><!-- chars-method -->
      
        <div id="close-method" class="method-detail ">
          <a name="method-i-close"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">close   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Closes <em>ios</em> and flushes any pending writes to the operating system.
The stream is unavailable for any further data operations; an <a
href="IOError.html">IOError</a> is raised if such an attempt is made. I/O
streams are automatically closed when they are claimed by the garbage
collector.</p>

<p>If <em>ios</em> is opened by <a href="IO.html#method-c-popen">::popen</a>,
<a href="IO.html#method-i-close">close</a> sets <code>$?</code>.</p>

<p>Calling this method on closed <a href="IO.html">IO</a> object is just
ignored since Ruby 2.3.</p>
            

            
            <div class="method-source-code" id="close-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_close_m(VALUE io)
{
    rb_io_t *fptr = rb_io_get_fptr(io);
    if (fptr-&gt;fd &lt; 0) {
        return Qnil;
    }
    rb_io_close(io);
    return Qnil;
}
            </pre> 
            </div><!-- close-source -->
            
          </div>

          

          
        </div><!-- close-method -->
      
        <div id="close_on_exec-3D-method" class="method-detail ">
          <a name="method-i-close_on_exec-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">close_on_exec = bool    &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets a close-on-exec flag.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/dev/null&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_on_exec</span> = <span class="ruby-keyword">true</span>
<span class="ruby-identifier">system</span>(<span class="ruby-string">&quot;cat&quot;</span>, <span class="ruby-node">&quot;/proc/self/fd/#{f.fileno}&quot;</span>) <span class="ruby-comment"># cat: /proc/self/fd/3: No such file or directory</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">closed?</span>                <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>Ruby sets close-on-exec flags of all file descriptors by default since Ruby
2.0.0. So you don&#39;t need to set by yourself. Also, unsetting a
close-on-exec flag can cause file descriptor leak if another thread use
fork() and exec() (via system() method for example). If you really needs
file descriptor inheritance to child process, use spawn()&#39;s argument
such as fd=&gt;fd.</p>
            

            
            <div class="method-source-code" id="close_on_exec-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_set_close_on_exec(VALUE io, VALUE arg)
{
    int flag = RTEST(arg) ? FD_CLOEXEC : 0;
    rb_io_t *fptr;
    VALUE write_io;
    int fd, ret;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        GetOpenFile(write_io, fptr);
        if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
            if ((ret = fcntl(fptr-&gt;fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
            if ((ret &amp; FD_CLOEXEC) != flag) {
                ret = (ret &amp; ~FD_CLOEXEC) | flag;
                ret = fcntl(fd, F_SETFD, ret);
                if (ret != 0) rb_sys_fail_path(fptr-&gt;pathv);
            }
        }

    }

    GetOpenFile(io, fptr);
    if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
        if ((ret &amp; FD_CLOEXEC) != flag) {
            ret = (ret &amp; ~FD_CLOEXEC) | flag;
            ret = fcntl(fd, F_SETFD, ret);
            if (ret != 0) rb_sys_fail_path(fptr-&gt;pathv);
        }
    }
    return Qnil;
}
            </pre> 
            </div><!-- close_on_exec-3D-source -->
            
          </div>

          

          
        </div><!-- close_on_exec-3D-method -->
      
        <div id="close_on_exec-3F-method" class="method-detail ">
          <a name="method-i-close_on_exec-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">close_on_exec?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>ios</em> will be closed on exec.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/dev/null&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_on_exec?</span>                 <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_on_exec</span> = <span class="ruby-keyword">true</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_on_exec?</span>                 <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_on_exec</span> = <span class="ruby-keyword">false</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_on_exec?</span>                 <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="close_on_exec-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_close_on_exec_p(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;
    int fd, ret;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        GetOpenFile(write_io, fptr);
        if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
            if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
            if (!(ret &amp; FD_CLOEXEC)) return Qfalse;
        }
    }

    GetOpenFile(io, fptr);
    if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
        if (!(ret &amp; FD_CLOEXEC)) return Qfalse;
    }
    return Qtrue;
}
            </pre> 
            </div><!-- close_on_exec-3F-source -->
            
          </div>

          

          
        </div><!-- close_on_exec-3F-method -->
      
        <div id="close_read-method" class="method-detail ">
          <a name="method-i-close_read"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">close_read    &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Closes the read end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe). Will raise an <a
href="IOError.html">IOError</a> if the stream is not duplexed.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;/bin/sh&quot;</span>,<span class="ruby-string">&quot;r+&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_read</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readlines</span>
</pre>

<p><em>produces:</em></p>

<pre>prog.rb:3:in `readlines&#39;: not opened for reading (IOError)
 from prog.rb:3</pre>

<p>Calling this method on closed <a href="IO.html">IO</a> object is just
ignored since Ruby 2.3.</p>
            

            
            <div class="method-source-code" id="close_read-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_close_read(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;

    fptr = rb_io_get_fptr(rb_io_taint_check(io));
    if (fptr-&gt;fd &lt; 0) return Qnil;
    if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {
#ifndef SHUT_RD
# define SHUT_RD 0
#endif
        if (shutdown(fptr-&gt;fd, SHUT_RD) &lt; 0)
            rb_sys_fail_path(fptr-&gt;pathv);
        fptr-&gt;mode &amp;= ~FMODE_READABLE;
        if (!(fptr-&gt;mode &amp; FMODE_WRITABLE))
            return rb_io_close(io);
        return Qnil;
    }

    write_io = GetWriteIO(io);
    if (io != write_io) {
        rb_io_t *wfptr;
        wfptr = rb_io_get_fptr(rb_io_taint_check(write_io));
        wfptr-&gt;pid = fptr-&gt;pid;
        fptr-&gt;pid = 0;
        RFILE(io)-&gt;fptr = wfptr;
        /* bind to write_io temporarily to get rid of memory/fd leak */
        fptr-&gt;tied_io_for_writing = 0;
        RFILE(write_io)-&gt;fptr = fptr;
        rb_io_fptr_cleanup(fptr, FALSE);
        /* should not finalize fptr because another thread may be reading it */
        return Qnil;
    }

    if ((fptr-&gt;mode &amp; (FMODE_DUPLEX|FMODE_WRITABLE)) == FMODE_WRITABLE) {
        rb_raise(rb_eIOError, &quot;closing non-duplex IO for reading&quot;);
    }
    return rb_io_close(io);
}
            </pre> 
            </div><!-- close_read-source -->
            
          </div>

          

          
        </div><!-- close_read-method -->
      
        <div id="close_write-method" class="method-detail ">
          <a name="method-i-close_write"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">close_write   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Closes the write end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe). Will raise an <a
href="IOError.html">IOError</a> if the stream is not duplexed.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;/bin/sh&quot;</span>,<span class="ruby-string">&quot;r+&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_write</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;nowhere&quot;</span>
</pre>

<p><em>produces:</em></p>

<pre>prog.rb:3:in `write&#39;: not opened for writing (IOError)
 from prog.rb:3:in `print&#39;
 from prog.rb:3</pre>

<p>Calling this method on closed <a href="IO.html">IO</a> object is just
ignored since Ruby 2.3.</p>
            

            
            <div class="method-source-code" id="close_write-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_close_write(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;

    write_io = GetWriteIO(io);
    fptr = rb_io_get_fptr(rb_io_taint_check(write_io));
    if (fptr-&gt;fd &lt; 0) return Qnil;
    if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {
#ifndef SHUT_WR
# define SHUT_WR 1
#endif
        if (shutdown(fptr-&gt;fd, SHUT_WR) &lt; 0)
            rb_sys_fail_path(fptr-&gt;pathv);
        fptr-&gt;mode &amp;= ~FMODE_WRITABLE;
        if (!(fptr-&gt;mode &amp; FMODE_READABLE))
            return rb_io_close(write_io);
        return Qnil;
    }

    if ((fptr-&gt;mode &amp; (FMODE_DUPLEX|FMODE_READABLE)) == FMODE_READABLE) {
        rb_raise(rb_eIOError, &quot;closing non-duplex IO for writing&quot;);
    }

    if (io != write_io) {
        fptr = rb_io_get_fptr(rb_io_taint_check(io));
        fptr-&gt;tied_io_for_writing = 0;
    }
    rb_io_close(write_io);
    return Qnil;
}
            </pre> 
            </div><!-- close_write-source -->
            
          </div>

          

          
        </div><!-- close_write-method -->
      
        <div id="closed-3F-method" class="method-detail ">
          <a name="method-i-closed-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">closed?    &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>ios</em> is completely closed (for duplex
streams, both reader and writer), <code>false</code> otherwise.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span>         <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">closed?</span>       <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">f</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;/bin/sh&quot;</span>,<span class="ruby-string">&quot;r+&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_write</span>   <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">closed?</span>       <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">close_read</span>    <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">closed?</span>       <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="closed-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_closed(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;
    rb_io_t *write_fptr;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        write_fptr = RFILE(write_io)-&gt;fptr;
        if (write_fptr &amp;&amp; 0 &lt;= write_fptr-&gt;fd) {
            return Qfalse;
        }
    }

    fptr = rb_io_get_fptr(io);
    return 0 &lt;= fptr-&gt;fd ? Qfalse : Qtrue;
}
            </pre> 
            </div><!-- closed-3F-source -->
            
          </div>

          

          
        </div><!-- closed-3F-method -->
      
        <div id="codepoints-method" class="method-detail ">
          <a name="method-i-codepoints"></a>

          
          <div class="method-heading">
            <span class="method-name">codepoints</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>This is a deprecated alias for <a
href="IO.html#method-i-each_codepoint">each_codepoint</a>.</p>
            

            
            <div class="method-source-code" id="codepoints-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_codepoints(VALUE io)
{
    rb_warn_deprecated(&quot;IO#codepoints&quot;, &quot;#each_codepoint&quot;);
    if (!rb_block_given_p())
        return rb_enumeratorize(io, ID2SYM(rb_intern(&quot;each_codepoint&quot;)), 0, 0);
    return rb_io_each_codepoint(io);
}
            </pre> 
            </div><!-- codepoints-source -->
            
          </div>

          

          
        </div><!-- codepoints-method -->
      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each(sep=$/ [, getline_args])          {|line| block } &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each(limit [, getline_args])           {|line| block } &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each(sep, limit [, getline_args])      {|line| block } &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each(...)                             &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep=$/ [, getline_args])     {|line| block } &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(limit [, getline_args])      {|line| block } &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep, limit [, getline_args]) {|line| block } &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(...)                        &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Executes the block for every line in <em>ios</em>, where lines are
separated by <em>sep</em>. <em>ios</em> must be opened for reading or an <a
href="IOError.html">IOError</a> will be raised.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{f.lineno}: #{line}&quot;</span> }
</pre>

<p><em>produces:</em></p>

<pre>1: This is line one
2: This is line two
3: This is line three
4: And so on...</pre>

<p>See <a href="IO.html#method-c-readlines">::readlines</a> for details about
getline_args.</p>
            

            
            <div class="method-source-code" id="each-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_each_line(int argc, VALUE *argv, VALUE io)
{
    VALUE str;
    struct getline_arg args;

    RETURN_ENUMERATOR(io, argc, argv);
    prepare_getline_args(argc, argv, &amp;args, io);
    if (args.limit == 0)
        rb_raise(rb_eArgError, &quot;invalid limit: 0 for each_line&quot;);
    while (!NIL_P(str = rb_io_getline_1(args.rs, args.limit, args.chomp, io))) {
        rb_yield(str);
    }
    return io;
}
            </pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->
      
        <div id="each_byte-method" class="method-detail ">
          <a name="method-i-each_byte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_byte {|byte| block }  &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_byte                  &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls the given block once for each byte (0..255) in <em>ios</em>, passing
the byte as an argument. The stream must be opened for reading or an <a
href="IOError.html">IOError</a> will be raised.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">checksum</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">each_byte</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">checksum</span> <span class="ruby-operator">^=</span> <span class="ruby-identifier">x</span> }   <span class="ruby-comment">#=&gt; #&lt;File:testfile&gt;</span>
<span class="ruby-identifier">checksum</span>                           <span class="ruby-comment">#=&gt; 12</span>
</pre>
            

            
            <div class="method-source-code" id="each_byte-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_each_byte(VALUE io)
{
    rb_io_t *fptr;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);

    do {
        while (fptr-&gt;rbuf.len &gt; 0) {
            char *p = fptr-&gt;rbuf.ptr + fptr-&gt;rbuf.off++;
            fptr-&gt;rbuf.len--;
            rb_yield(INT2FIX(*p &amp; 0xff));
            errno = 0;
        }
        rb_io_check_byte_readable(fptr);
        READ_CHECK(fptr);
    } while (io_fillbuf(fptr) &gt;= 0);
    return io;
}
            </pre> 
            </div><!-- each_byte-source -->
            
          </div>

          

          
        </div><!-- each_byte-method -->
      
        <div id="each_char-method" class="method-detail ">
          <a name="method-i-each_char"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_char {|c| block }  &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_char               &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls the given block once for each character in <em>ios</em>, passing the
character as an argument. The stream must be opened for reading or an <a
href="IOError.html">IOError</a> will be raised.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">each_char</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">c</span>, <span class="ruby-string">&#39; &#39;</span> }   <span class="ruby-comment">#=&gt; #&lt;File:testfile&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="each_char-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_each_char(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    VALUE c;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    enc = io_input_encoding(fptr);
    READ_CHECK(fptr);
    while (!NIL_P(c = io_getc(fptr, enc))) {
        rb_yield(c);
    }
    return io;
}
            </pre> 
            </div><!-- each_char-source -->
            
          </div>

          

          
        </div><!-- each_char-method -->
      
        <div id="each_codepoint-method" class="method-detail ">
          <a name="method-i-each_codepoint"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_codepoint {|c| block }  &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">codepoints     {|c| block }  &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_codepoint               &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">codepoints                   &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Passes the <a href="Integer.html">Integer</a> ordinal of each character in
<em>ios</em>, passing the codepoint as an argument. The stream must be
opened for reading or an <a href="IOError.html">IOError</a> will be raised.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="each_codepoint-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_each_codepoint(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    unsigned int c;
    int r, n;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    READ_CHECK(fptr);
    if (NEED_READCONV(fptr)) {
        SET_BINARY_MODE(fptr);
        r = 1;         /* no invalid char yet */
        for (;;) {
            make_readconv(fptr, 0);
            for (;;) {
                if (fptr-&gt;cbuf.len) {
                    if (fptr-&gt;encs.enc)
                        r = rb_enc_precise_mbclen(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,
                                                  fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,
                                                  fptr-&gt;encs.enc);
                    else
                        r = ONIGENC_CONSTRUCT_MBCLEN_CHARFOUND(1);
                    if (!MBCLEN_NEEDMORE_P(r))
                        break;
                    if (fptr-&gt;cbuf.len == fptr-&gt;cbuf.capa) {
                        rb_raise(rb_eIOError, &quot;too long character&quot;);
                    }
                }
                if (more_char(fptr) == MORE_CHAR_FINISHED) {
                    clear_readconv(fptr);
                    if (!MBCLEN_CHARFOUND_P(r)) {
                        enc = fptr-&gt;encs.enc;
                        goto invalid;
                    }
                    return io;
                }
            }
            if (MBCLEN_INVALID_P(r)) {
                enc = fptr-&gt;encs.enc;
                goto invalid;
            }
            n = MBCLEN_CHARFOUND_LEN(r);
            if (fptr-&gt;encs.enc) {
                c = rb_enc_codepoint(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,
                                     fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,
                                     fptr-&gt;encs.enc);
            }
            else {
                c = (unsigned char)fptr-&gt;cbuf.ptr[fptr-&gt;cbuf.off];
            }
            fptr-&gt;cbuf.off += n;
            fptr-&gt;cbuf.len -= n;
            rb_yield(UINT2NUM(c));
        }
    }
    NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);
    enc = io_input_encoding(fptr);
    while (io_fillbuf(fptr) &gt;= 0) {
        r = rb_enc_precise_mbclen(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off,
                                  fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off+fptr-&gt;rbuf.len, enc);
        if (MBCLEN_CHARFOUND_P(r) &amp;&amp;
            (n = MBCLEN_CHARFOUND_LEN(r)) &lt;= fptr-&gt;rbuf.len) {
            c = rb_enc_codepoint(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off,
                                 fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off+fptr-&gt;rbuf.len, enc);
            fptr-&gt;rbuf.off += n;
            fptr-&gt;rbuf.len -= n;
            rb_yield(UINT2NUM(c));
        }
        else if (MBCLEN_INVALID_P(r)) {
          invalid:
            rb_raise(rb_eArgError, &quot;invalid byte sequence in %s&quot;, rb_enc_name(enc));
        }
        else if (MBCLEN_NEEDMORE_P(r)) {
            char cbuf[8], *p = cbuf;
            int more = MBCLEN_NEEDMORE_LEN(r);
            if (more &gt; numberof(cbuf)) goto invalid;
            more += n = fptr-&gt;rbuf.len;
            if (more &gt; numberof(cbuf)) goto invalid;
            while ((n = (int)read_buffered_data(p, more, fptr)) &gt; 0 &amp;&amp;
                   (p += n, (more -= n) &gt; 0)) {
                if (io_fillbuf(fptr) &lt; 0) goto invalid;
                if ((n = fptr-&gt;rbuf.len) &gt; more) n = more;
            }
            r = rb_enc_precise_mbclen(cbuf, p, enc);
            if (!MBCLEN_CHARFOUND_P(r)) goto invalid;
            c = rb_enc_codepoint(cbuf, p, enc);
            rb_yield(UINT2NUM(c));
        }
        else {
            continue;
        }
    }
    return io;
}
            </pre> 
            </div><!-- each_codepoint-source -->
            
          </div>

          

          
        </div><!-- each_codepoint-method -->
      
        <div id="each_line-method" class="method-detail ">
          <a name="method-i-each_line"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep=$/ [, getline_args])     {|line| block } &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(limit [, getline_args])      {|line| block } &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(sep, limit [, getline_args]) {|line| block } &rarr; ios</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_line(...)                        &rarr; an_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Executes the block for every line in <em>ios</em>, where lines are
separated by <em>sep</em>. <em>ios</em> must be opened for reading or an <a
href="IOError.html">IOError</a> will be raised.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{f.lineno}: #{line}&quot;</span> }
</pre>

<p><em>produces:</em></p>

<pre>1: This is line one
2: This is line two
3: This is line three
4: And so on...</pre>

<p>See <a href="IO.html#method-c-readlines">::readlines</a> for details about
getline_args.</p>
            

            
            <div class="method-source-code" id="each_line-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_each_line(int argc, VALUE *argv, VALUE io)
{
    VALUE str;
    struct getline_arg args;

    RETURN_ENUMERATOR(io, argc, argv);
    prepare_getline_args(argc, argv, &amp;args, io);
    if (args.limit == 0)
        rb_raise(rb_eArgError, &quot;invalid limit: 0 for each_line&quot;);
    while (!NIL_P(str = rb_io_getline_1(args.rs, args.limit, args.chomp, io))) {
        rb_yield(str);
    }
    return io;
}
            </pre> 
            </div><!-- each_line-source -->
            
          </div>

          

          
        </div><!-- each_line-method -->
      
        <div id="eof-method" class="method-detail ">
          <a name="method-i-eof"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eof     &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">eof?    &rarr; true or false</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if <em>ios</em> is at end of file that means there are no more
data to read. The stream must be opened for reading or an <a
href="IOError.html">IOError</a> will be raised.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">dummy</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">readlines</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">eof</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>If <em>ios</em> is a stream such as pipe or socket, <a
href="IO.html#method-i-eof-3F">#eof?</a> blocks until the other end sends
some data or closes it.</p>

<pre class="ruby"><span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span> <span class="ruby-value">1</span>; <span class="ruby-identifier">w</span>.<span class="ruby-identifier">close</span> }
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">eof?</span>  <span class="ruby-comment">#=&gt; true after 1 second blocking</span>

<span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span> <span class="ruby-value">1</span>; <span class="ruby-identifier">w</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;a&quot;</span> }
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">eof?</span>  <span class="ruby-comment">#=&gt; false after 1 second blocking</span>

<span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">eof?</span>  <span class="ruby-comment"># blocks forever</span>
</pre>

<p>Note that <a href="IO.html#method-i-eof-3F">#eof?</a> reads data to the
input byte buffer.  So <a href="IO.html#method-i-sysread">#sysread</a> may
not behave as you intend with <a href="IO.html#method-i-eof-3F">#eof?</a>,
unless you call <a href="IO.html#method-i-rewind">#rewind</a> first (which
is not available for some streams).</p>
            

            
            <div class="method-source-code" id="eof-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_eof(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    if (READ_CHAR_PENDING(fptr)) return Qfalse;
    if (READ_DATA_PENDING(fptr)) return Qfalse;
    READ_CHECK(fptr);
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    if (!NEED_READCONV(fptr) &amp;&amp; NEED_NEWLINE_DECORATOR_ON_READ(fptr)) {
        return eof(fptr-&gt;fd) ? Qtrue : Qfalse;
    }
#endif
    if (io_fillbuf(fptr) &lt; 0) {
        return Qtrue;
    }
    return Qfalse;
}
            </pre> 
            </div><!-- eof-source -->
            
          </div>

          

          
        </div><!-- eof-method -->
      
        <div id="eof-3F-method" class="method-detail ">
          <a name="method-i-eof-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eof?    &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if <em>ios</em> is at end of file that means there are no more
data to read. The stream must be opened for reading or an <a
href="IOError.html">IOError</a> will be raised.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">dummy</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">readlines</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">eof</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>If <em>ios</em> is a stream such as pipe or socket, <a
href="IO.html#method-i-eof-3F">#eof?</a> blocks until the other end sends
some data or closes it.</p>

<pre class="ruby"><span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span> <span class="ruby-value">1</span>; <span class="ruby-identifier">w</span>.<span class="ruby-identifier">close</span> }
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">eof?</span>  <span class="ruby-comment">#=&gt; true after 1 second blocking</span>

<span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>
<span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">sleep</span> <span class="ruby-value">1</span>; <span class="ruby-identifier">w</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;a&quot;</span> }
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">eof?</span>  <span class="ruby-comment">#=&gt; false after 1 second blocking</span>

<span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">eof?</span>  <span class="ruby-comment"># blocks forever</span>
</pre>

<p>Note that <a href="IO.html#method-i-eof-3F">#eof?</a> reads data to the
input byte buffer.  So <a href="IO.html#method-i-sysread">#sysread</a> may
not behave as you intend with <a href="IO.html#method-i-eof-3F">#eof?</a>,
unless you call <a href="IO.html#method-i-rewind">#rewind</a> first (which
is not available for some streams).</p>
            

            
            <div class="method-source-code" id="eof-3F-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_eof(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    if (READ_CHAR_PENDING(fptr)) return Qfalse;
    if (READ_DATA_PENDING(fptr)) return Qfalse;
    READ_CHECK(fptr);
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    if (!NEED_READCONV(fptr) &amp;&amp; NEED_NEWLINE_DECORATOR_ON_READ(fptr)) {
        return eof(fptr-&gt;fd) ? Qtrue : Qfalse;
    }
#endif
    if (io_fillbuf(fptr) &lt; 0) {
        return Qtrue;
    }
    return Qfalse;
}
            </pre> 
            </div><!-- eof-3F-source -->
            
          </div>

          

          
        </div><!-- eof-3F-method -->
      
        <div id="external_encoding-method" class="method-detail ">
          <a name="method-i-external_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">external_encoding   &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <a href="Encoding.html">Encoding</a> object that represents the
encoding of the file. If <em>io</em> is in write mode and no encoding is
specified, returns <code>nil</code>.</p>
            

            
            <div class="method-source-code" id="external_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_external_encoding(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (fptr-&gt;encs.enc2) {
        return rb_enc_from_encoding(fptr-&gt;encs.enc2);
    }
    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        if (fptr-&gt;encs.enc)
            return rb_enc_from_encoding(fptr-&gt;encs.enc);
        return Qnil;
    }
    return rb_enc_from_encoding(io_read_encoding(fptr));
}
            </pre> 
            </div><!-- external_encoding-source -->
            
          </div>

          

          
        </div><!-- external_encoding-method -->
      
        <div id="fcntl-method" class="method-detail ">
          <a name="method-i-fcntl"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fcntl(integer_cmd, arg)    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Provides a mechanism for issuing low-level commands to control or query
file-oriented I/O streams. Arguments and results are platform dependent. If
<em>arg</em> is a number, its value is passed directly. If it is a string,
it is interpreted as a binary sequence of bytes (Array#pack might be a
useful way to build this string). On Unix platforms, see
<code>fcntl(2)</code> for details.  Not implemented on all platforms.</p>
            

            
            <div class="method-source-code" id="fcntl-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_fcntl(int argc, VALUE *argv, VALUE io)
{
    VALUE req, arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;req, &amp;arg);
    return rb_fcntl(io, req, arg);
}
            </pre> 
            </div><!-- fcntl-source -->
            
          </div>

          

          
        </div><!-- fcntl-method -->
      
        <div id="fdatasync-method" class="method-detail ">
          <a name="method-i-fdatasync"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fdatasync   &rarr; 0 or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Immediately writes all buffered data in <em>ios</em> to disk.</p>

<p>If the underlying operating system does not support <em>fdatasync(2)</em>,
<a href="IO.html#method-i-fsync">#fsync</a> is called instead (which might
raise a <a href="NotImplementedError.html">NotImplementedError</a>).</p>
            

            
            <div class="method-source-code" id="fdatasync-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_fdatasync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    if (io_fflush(fptr) &lt; 0)
        rb_sys_fail(0);

    if ((int)rb_thread_io_blocking_region(nogvl_fdatasync, fptr, fptr-&gt;fd) == 0)
        return INT2FIX(0);

    /* fall back */
    return rb_io_fsync(io);
}
            </pre> 
            </div><!-- fdatasync-source -->
            
          </div>

          

          
        </div><!-- fdatasync-method -->
      
        <div id="fileno-method" class="method-detail ">
          <a name="method-i-fileno"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fileno    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">to_i      &rarr; integer</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an integer representing the numeric file descriptor for
<em>ios</em>.</p>

<pre class="ruby"><span class="ruby-identifier">$stdin</span>.<span class="ruby-identifier">fileno</span>    <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">fileno</span>   <span class="ruby-comment">#=&gt; 1</span>
</pre>
            

            
            <div class="method-source-code" id="fileno-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_fileno(VALUE io)
{
    rb_io_t *fptr = RFILE(io)-&gt;fptr;
    int fd;

    rb_io_check_closed(fptr);
    fd = fptr-&gt;fd;
    return INT2FIX(fd);
}
            </pre> 
            </div><!-- fileno-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="IO.html#method-i-to_i">to_i</a>
          </div>
          

          
        </div><!-- fileno-method -->
      
        <div id="flush-method" class="method-detail ">
          <a name="method-i-flush"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flush    &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Flushes any buffered data within <em>ios</em> to the underlying operating
system (note that this is Ruby internal buffering only; the OS may buffer
the data as well).</p>

<pre class="ruby"><span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;no newline&quot;</span>
<span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">flush</span>
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-identifier">no</span> <span class="ruby-identifier">newline</span>
</pre>
            

            
            <div class="method-source-code" id="flush-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_flush(VALUE io)
{
    return rb_io_flush_raw(io, 1);
}
            </pre> 
            </div><!-- flush-source -->
            
          </div>

          

          
        </div><!-- flush-method -->
      
        <div id="fsync-method" class="method-detail ">
          <a name="method-i-fsync"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fsync   &rarr; 0 or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Immediately writes all buffered data in <em>ios</em> to disk. Note that <a
href="IO.html#method-i-fsync">fsync</a> differs from using <a
href="IO.html#method-i-sync-3D">#sync=</a>. The latter ensures that data is
flushed from Ruby&#39;s buffers, but does not guarantee that the underlying
operating system actually writes it to disk.</p>

<p><a href="NotImplementedError.html">NotImplementedError</a> is raised if the
underlying operating system does not support <em>fsync(2)</em>.</p>
            

            
            <div class="method-source-code" id="fsync-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_fsync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    if (io_fflush(fptr) &lt; 0)
        rb_sys_fail(0);
    if ((int)rb_thread_io_blocking_region(nogvl_fsync, fptr, fptr-&gt;fd) &lt; 0)
        rb_sys_fail_path(fptr-&gt;pathv);
    return INT2FIX(0);
}
            </pre> 
            </div><!-- fsync-source -->
            
          </div>

          

          
        </div><!-- fsync-method -->
      
        <div id="getbyte-method" class="method-detail ">
          <a name="method-i-getbyte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">getbyte   &rarr; integer or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Gets the next 8-bit byte (0..255) from <em>ios</em>. Returns
<code>nil</code> if called at end of file.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">getbyte</span>   <span class="ruby-comment">#=&gt; 84</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">getbyte</span>   <span class="ruby-comment">#=&gt; 104</span>
</pre>
            

            
            <div class="method-source-code" id="getbyte-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_getbyte(VALUE io)
{
    rb_io_t *fptr;
    int c;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    READ_CHECK(fptr);
    if (fptr-&gt;fd == 0 &amp;&amp; (fptr-&gt;mode &amp; FMODE_TTY) &amp;&amp; RB_TYPE_P(rb_stdout, T_FILE)) {
        rb_io_t *ofp;
        GetOpenFile(rb_stdout, ofp);
        if (ofp-&gt;mode &amp; FMODE_TTY) {
            rb_io_flush(rb_stdout);
        }
    }
    if (io_fillbuf(fptr) &lt; 0) {
        return Qnil;
    }
    fptr-&gt;rbuf.off++;
    fptr-&gt;rbuf.len--;
    c = (unsigned char)fptr-&gt;rbuf.ptr[fptr-&gt;rbuf.off-1];
    return INT2FIX(c &amp; 0xff);
}
            </pre> 
            </div><!-- getbyte-source -->
            
          </div>

          

          
        </div><!-- getbyte-method -->
      
        <div id="getc-method" class="method-detail ">
          <a name="method-i-getc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">getc   &rarr; string or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads a one-character string from <em>ios</em>. Returns <code>nil</code> if
called at end of file.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">getc</span>   <span class="ruby-comment">#=&gt; &quot;h&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">getc</span>   <span class="ruby-comment">#=&gt; &quot;e&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="getc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_getc(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    enc = io_input_encoding(fptr);
    READ_CHECK(fptr);
    return io_getc(fptr, enc);
}
            </pre> 
            </div><!-- getc-source -->
            
          </div>

          

          
        </div><!-- getc-method -->
      
        <div id="gets-method" class="method-detail ">
          <a name="method-i-gets"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">gets(sep=$/ [, getline_args])     &rarr; string or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gets(limit [, getline_args])      &rarr; string or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">gets(sep, limit [, getline_args]) &rarr; string or nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads the next “line&#39;&#39; from the I/O stream; lines are separated by
<em>sep</em>. A separator of <code>nil</code> reads the entire contents,
and a zero-length separator reads the input a paragraph at a time (two
successive newlines in the input separate paragraphs). The stream must be
opened for reading or an <a href="IOError.html">IOError</a> will be raised.
The line read in will be returned and also assigned to <code>$_</code>.
Returns <code>nil</code> if called at end of file.  If the first argument
is an integer, or optional second argument is given, the returning string
would not be longer than the given value in bytes.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">gets</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-identifier">$_</span>                          <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">gets</span>(<span class="ruby-value">4</span>)<span class="ruby-comment">#=&gt; &quot;This&quot;</span>
</pre>

<p>If <a href="IO.html">IO</a> contains multibyte characters byte then
<code>gets(1)</code> returns character entirely:</p>

<pre class="ruby"><span class="ruby-comment"># Russian characters take 2 bytes</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;\u{442 435 441 442}&quot;</span>)
<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;testfile&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span><span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>(<span class="ruby-value">1</span>)} <span class="ruby-comment">#=&gt; &quot;\u0442&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;testfile&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span><span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>(<span class="ruby-value">2</span>)} <span class="ruby-comment">#=&gt; &quot;\u0442&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;testfile&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span><span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>(<span class="ruby-value">3</span>)} <span class="ruby-comment">#=&gt; &quot;\u0442\u0435&quot;</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;testfile&quot;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span><span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>(<span class="ruby-value">4</span>)} <span class="ruby-comment">#=&gt; &quot;\u0442\u0435&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="gets-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_gets_m(int argc, VALUE *argv, VALUE io)
{
    VALUE str;

    str = rb_io_getline(argc, argv, io);
    rb_lastline_set(str);

    return str;
}
            </pre> 
            </div><!-- gets-source -->
            
          </div>

          

          
        </div><!-- gets-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Return a string describing this <a href="IO.html">IO</a> object.</p>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_inspect(VALUE obj)
{
    rb_io_t *fptr;
    VALUE result;
    static const char closed[] = &quot; (closed)&quot;;

    fptr = RFILE(obj)-&gt;fptr;
    if (!fptr) return rb_any_to_s(obj);
    result = rb_str_new_cstr(&quot;#&lt;&quot;);
    rb_str_append(result, rb_class_name(CLASS_OF(obj)));
    rb_str_cat2(result, &quot;:&quot;);
    if (NIL_P(fptr-&gt;pathv)) {
        if (fptr-&gt;fd &lt; 0) {
            rb_str_cat(result, closed+1, strlen(closed)-1);
        }
        else {
            rb_str_catf(result, &quot;fd %d&quot;, fptr-&gt;fd);
        }
    }
    else {
        rb_str_append(result, fptr-&gt;pathv);
        if (fptr-&gt;fd &lt; 0) {
            rb_str_cat(result, closed, strlen(closed));
        }
    }
    return rb_str_cat2(result, &quot;&gt;&quot;);
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->
      
        <div id="internal_encoding-method" class="method-detail ">
          <a name="method-i-internal_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">internal_encoding   &rarr; encoding</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <a href="Encoding.html">Encoding</a> of the internal string if
conversion is specified.  Otherwise returns <code>nil</code>.</p>
            

            
            <div class="method-source-code" id="internal_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_internal_encoding(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!fptr-&gt;encs.enc2) return Qnil;
    return rb_enc_from_encoding(io_read_encoding(fptr));
}
            </pre> 
            </div><!-- internal_encoding-source -->
            
          </div>

          

          
        </div><!-- internal_encoding-method -->
      
        <div id="ioctl-method" class="method-detail ">
          <a name="method-i-ioctl"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ioctl(integer_cmd, arg)    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Provides a mechanism for issuing low-level commands to control or query I/O
devices. Arguments and results are platform dependent. If <em>arg</em> is a
number, its value is passed directly. If it is a string, it is interpreted
as a binary sequence of bytes. On Unix platforms, see <code>ioctl(2)</code>
for details. Not implemented on all platforms.</p>
            

            
            <div class="method-source-code" id="ioctl-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_ioctl(int argc, VALUE *argv, VALUE io)
{
    VALUE req, arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;req, &amp;arg);
    return rb_ioctl(io, req, arg);
}
            </pre> 
            </div><!-- ioctl-source -->
            
          </div>

          

          
        </div><!-- ioctl-method -->
      
        <div id="isatty-method" class="method-detail ">
          <a name="method-i-isatty"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">isatty   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>ios</em> is associated with a terminal
device (tty), <code>false</code> otherwise.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">isatty</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;/dev/tty&quot;</span>).<span class="ruby-identifier">isatty</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="isatty-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_isatty(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (isatty(fptr-&gt;fd) == 0)
        return Qfalse;
    return Qtrue;
}
            </pre> 
            </div><!-- isatty-source -->
            
          </div>

          

          
        </div><!-- isatty-method -->
      
        <div id="lineno-method" class="method-detail ">
          <a name="method-i-lineno"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lineno    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current line number in <em>ios</em>.  The stream must be opened
for reading. <a href="IO.html#method-i-lineno">lineno</a> counts the number
of times <a href="IO.html#method-i-gets">gets</a> is called rather than the
number of newlines encountered.  The two values will differ if <a
href="IO.html#method-i-gets">gets</a> is called with a separator other than
newline.</p>

<p>Methods that use <code>$/</code> like <a
href="IO.html#method-i-each">each</a>, <a
href="IO.html#method-i-lines">lines</a> and <a
href="IO.html#method-i-readline">readline</a> will also increment <a
href="IO.html#method-i-lineno">lineno</a>.</p>

<p>See also the <code>$.</code> variable.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">lineno</span>   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>     <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">lineno</span>   <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>     <span class="ruby-comment">#=&gt; &quot;This is line two\n&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">lineno</span>   <span class="ruby-comment">#=&gt; 2</span>
</pre>
            

            
            <div class="method-source-code" id="lineno-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_lineno(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    return INT2NUM(fptr-&gt;lineno);
}
            </pre> 
            </div><!-- lineno-source -->
            
          </div>

          

          
        </div><!-- lineno-method -->
      
        <div id="lineno-3D-method" class="method-detail ">
          <a name="method-i-lineno-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">lineno = integer    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Manually sets the current line number to the given value. <code>$.</code>
is updated only on the next read.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>                     <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-identifier">$.</span>                         <span class="ruby-comment">#=&gt; 1</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">lineno</span> = <span class="ruby-value">1000</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">lineno</span>                   <span class="ruby-comment">#=&gt; 1000</span>
<span class="ruby-identifier">$.</span>                         <span class="ruby-comment">#=&gt; 1         # lineno of last read</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>                     <span class="ruby-comment">#=&gt; &quot;This is line two\n&quot;</span>
<span class="ruby-identifier">$.</span>                         <span class="ruby-comment">#=&gt; 1001      # lineno of last read</span>
</pre>
            

            
            <div class="method-source-code" id="lineno-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_set_lineno(VALUE io, VALUE lineno)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    fptr-&gt;lineno = NUM2INT(lineno);
    return lineno;
}
            </pre> 
            </div><!-- lineno-3D-source -->
            
          </div>

          

          
        </div><!-- lineno-3D-method -->
      
        <div id="lines-method" class="method-detail ">
          <a name="method-i-lines"></a>

          
          <div class="method-heading">
            <span class="method-name">lines</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>This is a deprecated alias for <a
href="IO.html#method-i-each_line">each_line</a>.</p>
            

            
            <div class="method-source-code" id="lines-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_lines(int argc, VALUE *argv, VALUE io)
{
    rb_warn_deprecated(&quot;IO#lines&quot;, &quot;#each_line&quot;);
    if (!rb_block_given_p())
        return rb_enumeratorize(io, ID2SYM(rb_intern(&quot;each_line&quot;)), argc, argv);
    return rb_io_each_line(argc, argv, io);
}
            </pre> 
            </div><!-- lines-source -->
            
          </div>

          

          
        </div><!-- lines-method -->
      
        <div id="pid-method" class="method-detail ">
          <a name="method-i-pid"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pid    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the process ID of a child process associated with <em>ios</em>.
This will be set by <a href="IO.html#method-c-popen">::popen</a>.</p>

<pre class="ruby"><span class="ruby-identifier">pipe</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">popen</span>(<span class="ruby-string">&quot;-&quot;</span>)
<span class="ruby-keyword">if</span> <span class="ruby-identifier">pipe</span>
  <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;In parent, child pid is #{pipe.pid}&quot;</span>
<span class="ruby-keyword">else</span>
  <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;In child, pid is #{$$}&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p><em>produces:</em></p>

<pre>In child, pid is 26209
In parent, child pid is 26209</pre>
            

            
            <div class="method-source-code" id="pid-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_pid(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!fptr-&gt;pid)
        return Qnil;
    return PIDT2NUM(fptr-&gt;pid);
}
            </pre> 
            </div><!-- pid-source -->
            
          </div>

          

          
        </div><!-- pid-method -->
      
        <div id="pos-method" class="method-detail ">
          <a name="method-i-pos"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pos     &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current offset (in bytes) of <em>ios</em>.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 17</span>
</pre>
            

            
            <div class="method-source-code" id="pos-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_tell(VALUE io)
{
    rb_io_t *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_tell(fptr);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    pos -= fptr-&gt;rbuf.len;
    return OFFT2NUM(pos);
}
            </pre> 
            </div><!-- pos-source -->
            
          </div>

          

          
        </div><!-- pos-method -->
      
        <div id="pos-3D-method" class="method-detail ">
          <a name="method-i-pos-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pos = integer    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Seeks to the given position (in bytes) in <em>ios</em>. It is not
guaranteed that seeking to the right position when <em>ios</em> is
textmode.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">pos</span> = <span class="ruby-value">17</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>   <span class="ruby-comment">#=&gt; &quot;This is line two\n&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="pos-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_set_pos(VALUE io, VALUE offset)
{
    rb_io_t *fptr;
    off_t pos;

    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    pos = io_seek(fptr, pos, SEEK_SET);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

    return OFFT2NUM(pos);
}
            </pre> 
            </div><!-- pos-3D-source -->
            
          </div>

          

          
        </div><!-- pos-3D-method -->
      
        <div id="pread-method" class="method-detail ">
          <a name="method-i-pread"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pread(maxlen, offset[, outbuf])    &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads <em>maxlen</em> bytes from <em>ios</em> using the pread system call
and returns them as a string without modifying the underlying descriptor
offset.  This is advantageous compared to combining <a
href="IO.html#method-i-seek">#seek</a> and <a
href="IO.html#method-i-read">#read</a> in that it is atomic, allowing
multiple threads/process to share the same <a href="IO.html">IO</a> object
for reading the file at various locations. This bypasses any userspace
buffering of the <a href="IO.html">IO</a> layer. If the optional
<em>outbuf</em> argument is present, it must reference a <a
href="String.html">String</a>, which will receive the data. Raises <a
href="SystemCallError.html">SystemCallError</a> on error, <a
href="EOFError.html">EOFError</a> at end of file and <a
href="NotImplementedError.html">NotImplementedError</a> if platform does
not implement the system call.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-string">&quot;This is line one\nThis is line two\n&quot;</span>)
<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;testfile&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">p</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>           <span class="ruby-comment"># =&gt; &quot;This is line one\nThis is line two\n&quot;</span>
  <span class="ruby-identifier">p</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">pread</span>(<span class="ruby-value">12</span>, <span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; &quot;This is line&quot;</span>
  <span class="ruby-identifier">p</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">pread</span>(<span class="ruby-value">9</span>, <span class="ruby-value">8</span>)    <span class="ruby-comment"># =&gt; &quot;line one\n&quot;</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="pread-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_pread(int argc, VALUE *argv, VALUE io)
{
    VALUE len, offset, str;
    rb_io_t *fptr;
    ssize_t n;
    struct prdwr_internal_arg arg;
    int shrinkable;

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;len, &amp;offset, &amp;str);
    arg.count = NUM2SIZET(len);
    arg.offset = NUM2OFFT(offset);

    shrinkable = io_setstrbuf(&amp;str, (long)arg.count);
    if (arg.count == 0) return str;
    arg.buf = RSTRING_PTR(str);

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);

    arg.fd = fptr-&gt;fd;
    rb_io_check_closed(fptr);

    rb_str_locktmp(str);
    n = (ssize_t)rb_ensure(pread_internal_call, (VALUE)&amp;arg, rb_str_unlocktmp, str);

    if (n &lt; 0) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    io_set_read_length(str, n, shrinkable);
    if (n == 0 &amp;&amp; arg.count &gt; 0) {
        rb_eof_error();
    }

    return str;
}
            </pre> 
            </div><!-- pread-source -->
            
          </div>

          

          
        </div><!-- pread-method -->
      
        <div id="print-method" class="method-detail ">
          <a name="method-i-print"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">print               &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">print(obj, ...)     &rarr; nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given object(s) to <em>ios</em>. Returns <code>nil</code>.</p>

<p>The stream must be opened for writing. Each given object that isn&#39;t a
string will be converted by calling its <code>to_s</code> method. When
called without arguments, prints the contents of <code>$_</code>.</p>

<p>If the output field separator (<code>$,</code>) is not <code>nil</code>, it
is inserted between objects. If the output record separator
(<code>$\</code>) is not <code>nil</code>, it is appended to the output.</p>

<pre class="ruby"><span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">print</span>(<span class="ruby-string">&quot;This is &quot;</span>, <span class="ruby-value">100</span>, <span class="ruby-string">&quot; percent.\n&quot;</span>)
</pre>

<p><em>produces:</em></p>

<pre>This is 100 percent.</pre>
            

            
            <div class="method-source-code" id="print-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_print(int argc, const VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print `$_&#39; */
    if (argc == 0) {
        argc = 1;
        line = rb_lastline_get();
        argv = &amp;line;
    }
    for (i=0; i&lt;argc; i++) {
        if (!NIL_P(rb_output_fs) &amp;&amp; i&gt;0) {
            rb_io_write(out, rb_output_fs);
        }
        rb_io_write(out, argv[i]);
    }
    if (argc &gt; 0 &amp;&amp; !NIL_P(rb_output_rs)) {
        rb_io_write(out, rb_output_rs);
    }

    return Qnil;
}
            </pre> 
            </div><!-- print-source -->
            
          </div>

          

          
        </div><!-- print-method -->
      
        <div id="printf-method" class="method-detail ">
          <a name="method-i-printf"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">printf(format_string [, obj, ...])   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Formats and writes to <em>ios</em>, converting parameters under control of
the format string. See <a
href="Kernel.html#method-i-sprintf">Kernel#sprintf</a> for details.</p>
            

            
            <div class="method-source-code" id="printf-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_printf(int argc, const VALUE *argv, VALUE out)
{
    rb_io_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}
            </pre> 
            </div><!-- printf-source -->
            
          </div>

          

          
        </div><!-- printf-method -->
      
        <div id="putc-method" class="method-detail ">
          <a name="method-i-putc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">putc(obj)    &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>If <em>obj</em> is <a href="Numeric.html">Numeric</a>, write the character
whose code is the least-significant byte of <em>obj</em>.  If <em>obj</em>
is <a href="String.html">String</a>, write the first character of
<em>obj</em> to <em>ios</em>.  Otherwise, raise <a
href="TypeError.html">TypeError</a>.</p>

<pre class="ruby"><span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">putc</span> <span class="ruby-string">&quot;A&quot;</span>
<span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">putc</span> <span class="ruby-value">65</span>
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-constant">AA</span>
</pre>
            

            
            <div class="method-source-code" id="putc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_putc(VALUE io, VALUE ch)
{
    VALUE str;
    if (RB_TYPE_P(ch, T_STRING)) {
        str = rb_str_substr(ch, 0, 1);
    }
    else {
        char c = NUM2CHR(ch);
        str = rb_str_new(&amp;c, 1);
    }
    rb_io_write(io, str);
    return ch;
}
            </pre> 
            </div><!-- putc-source -->
            
          </div>

          

          
        </div><!-- putc-method -->
      
        <div id="puts-method" class="method-detail ">
          <a name="method-i-puts"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">puts(obj, ...)    &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given object(s) to <em>ios</em>. Writes a newline after any that
do not already end with a newline sequence. Returns <code>nil</code>.</p>

<p>The stream must be opened for writing. If called with an array argument,
writes each element on a new line. Each given object that isn&#39;t a
string or array will be converted by calling its <code>to_s</code> method.
If called without arguments, outputs a single newline.</p>

<pre class="ruby"><span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">puts</span>(<span class="ruby-string">&quot;this&quot;</span>, <span class="ruby-string">&quot;is&quot;</span>, [<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;test&quot;</span>])
</pre>

<p><em>produces:</em></p>

<pre class="ruby"><span class="ruby-identifier">this</span>
<span class="ruby-identifier">is</span>
<span class="ruby-identifier">a</span>
<span class="ruby-identifier">test</span>
</pre>

<p>Note that <code>puts</code> always uses newlines and is not affected by the
output record separator (<code>$\</code>).</p>
            

            
            <div class="method-source-code" id="puts-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_puts(int argc, const VALUE *argv, VALUE out)
{
    int i, n;
    VALUE line, args[2];

    /* if no argument given, print newline. */
    if (argc == 0) {
        rb_io_write(out, rb_default_rs);
        return Qnil;
    }
    for (i=0; i&lt;argc; i++) {
        if (RB_TYPE_P(argv[i], T_STRING)) {
            line = argv[i];
            goto string;
        }
        if (rb_exec_recursive(io_puts_ary, argv[i], out)) {
            continue;
        }
        line = rb_obj_as_string(argv[i]);
      string:
        n = 0;
        args[n++] = line;
        if (RSTRING_LEN(line) == 0 ||
            !rb_str_end_with_asciichar(line, &#39;\n&#39;)) {
            args[n++] = rb_default_rs;
        }
        rb_io_writev(out, n, args);
    }

    return Qnil;
}
            </pre> 
            </div><!-- puts-source -->
            
          </div>

          

          
        </div><!-- puts-method -->
      
        <div id="pwrite-method" class="method-detail ">
          <a name="method-i-pwrite"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pwrite(string, offset)    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given string to <em>ios</em> at <em>offset</em> using pwrite()
system call.  This is advantageous to combining <a
href="IO.html#method-i-seek">#seek</a> and <a
href="IO.html#method-i-write">#write</a> in that it is atomic, allowing
multiple threads/process to share the same <a href="IO.html">IO</a> object
for reading the file at various locations. This bypasses any userspace
buffering of the <a href="IO.html">IO</a> layer. Returns the number of
bytes written. Raises <a href="SystemCallError.html">SystemCallError</a> on
error and <a href="NotImplementedError.html">NotImplementedError</a> if
platform does not implement the system call.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;out&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">pwrite</span>(<span class="ruby-string">&quot;ABCDEF&quot;</span>, <span class="ruby-value">3</span>)   <span class="ruby-comment">#=&gt; 6</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span>(<span class="ruby-string">&quot;out&quot;</span>)          <span class="ruby-comment">#=&gt; &quot;\u0000\u0000\u0000ABCDEF&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="pwrite-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_pwrite(VALUE io, VALUE str, VALUE offset)
{
    rb_io_t *fptr;
    ssize_t n;
    struct prdwr_internal_arg arg;
    VALUE tmp;

    if (!RB_TYPE_P(str, T_STRING))
        str = rb_obj_as_string(str);

    arg.offset = NUM2OFFT(offset);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    arg.fd = fptr-&gt;fd;

    tmp = rb_str_tmp_frozen_acquire(str);
    arg.buf = RSTRING_PTR(tmp);
    arg.count = (size_t)RSTRING_LEN(tmp);

    n = (ssize_t)rb_thread_io_blocking_region(internal_pwrite_func, &amp;arg, fptr-&gt;fd);
    if (n &lt; 0) rb_sys_fail_path(fptr-&gt;pathv);
    rb_str_tmp_frozen_release(str, tmp);

    return SSIZET2NUM(n);
}
            </pre> 
            </div><!-- pwrite-source -->
            
          </div>

          

          
        </div><!-- pwrite-method -->
      
        <div id="read-method" class="method-detail ">
          <a name="method-i-read"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">read([length [, outbuf]])    &rarr; string, outbuf, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads <em>length</em> bytes from the I/O stream.</p>

<p><em>length</em> must be a non-negative integer or <code>nil</code>.</p>

<p>If <em>length</em> is a positive integer, <code>read</code> tries to read
<em>length</em> bytes without any conversion (binary mode). It returns
<code>nil</code> if an EOF is encountered before anything can be read.
Fewer than <em>length</em> bytes are returned if an EOF is encountered
during the read. In the case of an integer <em>length</em>, the resulting
string is always in ASCII-8BIT encoding.</p>

<p>If <em>length</em> is omitted or is <code>nil</code>, it reads until EOF
and the encoding conversion is applied, if applicable. A string is returned
even if EOF is encountered before any data is read.</p>

<p>If <em>length</em> is zero, it returns an empty string
(<code>&quot;&quot;</code>).</p>

<p>If the optional <em>outbuf</em> argument is present, it must reference a <a
href="String.html">String</a>, which will receive the data. The
<em>outbuf</em> will contain only the received data after the method call
even if it is not empty at the beginning.</p>

<p>When this method is called at end of file, it returns <code>nil</code> or
<code>&quot;&quot;</code>, depending on <em>length</em>: <code>read</code>,
<code>read(nil)</code>, and <code>read(0)</code> return
<code>&quot;&quot;</code>, <code>read(<em>positive_integer</em>)</code>
returns <code>nil</code>.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">16</span>)   <span class="ruby-comment">#=&gt; &quot;This is line one&quot;</span>

<span class="ruby-comment"># read whole file</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;file&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">data</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>   <span class="ruby-comment"># This returns a string even if the file is empty.</span>
  <span class="ruby-comment"># ...</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># iterate over fixed length records</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;fixed-record-file&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">record</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">256</span>)
    <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-comment"># iterate over variable length records,</span>
<span class="ruby-comment"># each record is prefixed by its 32-bit length</span>
<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;variable-record-file&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">len</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>(<span class="ruby-value">4</span>)
    <span class="ruby-identifier">len</span> = <span class="ruby-identifier">len</span>.<span class="ruby-identifier">unpack</span>(<span class="ruby-string">&quot;N&quot;</span>)[<span class="ruby-value">0</span>]   <span class="ruby-comment"># 32-bit length</span>
    <span class="ruby-identifier">record</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">len</span>)       <span class="ruby-comment"># This returns a string even if len is 0.</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Note that this method behaves like the fread() function in C. This means it
retries to invoke read(2) system calls to read data with the specified
length (or until EOF). This behavior is preserved even if <em>ios</em> is
in non-blocking mode. (This method is non-blocking flag insensitive as
other methods.) If you need the behavior like a single read(2) system call,
consider <a href="IO.html#method-i-readpartial">readpartial</a>, <a
href="IO.html#method-i-read_nonblock">read_nonblock</a>, and <a
href="IO.html#method-i-sysread">sysread</a>.</p>
            

            
            <div class="method-source-code" id="read-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
io_read(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr;
    long n, len;
    VALUE length, str;
    int shrinkable;
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    int previous_mode;
#endif

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;length, &amp;str);

    if (NIL_P(length)) {
        GetOpenFile(io, fptr);
        rb_io_check_char_readable(fptr);
        return read_all(fptr, remain_size(fptr), str);
    }
    len = NUM2LONG(length);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative length %ld given&quot;, len);
    }

    shrinkable = io_setstrbuf(&amp;str,len);

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    if (len == 0) {
        io_set_read_length(str, 0, shrinkable);
        return str;
    }

    READ_CHECK(fptr);
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    previous_mode = set_binary_mode_with_seek_cur(fptr);
#endif
    n = io_fread(str, 0, len, fptr);
    io_set_read_length(str, n, shrinkable);
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    if (previous_mode == O_TEXT) {
        setmode(fptr-&gt;fd, O_TEXT);
    }
#endif
    if (n == 0) return Qnil;

    return str;
}
            </pre> 
            </div><!-- read-source -->
            
          </div>

          

          
        </div><!-- read-method -->
      
        <div id="read_nonblock-method" class="method-detail ">
          <a name="method-i-read_nonblock"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">read_nonblock(maxlen [, options])              &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">read_nonblock(maxlen, outbuf [, options])      &rarr; outbuf</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads at most <em>maxlen</em> bytes from <em>ios</em> using the read(2)
system call after O_NONBLOCK is set for the underlying file descriptor.</p>

<p>If the optional <em>outbuf</em> argument is present, it must reference a <a
href="String.html">String</a>, which will receive the data. The
<em>outbuf</em> will contain only the received data after the method call
even if it is not empty at the beginning.</p>

<p><a href="IO.html#method-i-read_nonblock">#read_nonblock</a> just calls the
read(2) system call. It causes all errors the read(2) system call causes:
Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller should care such errors.</p>

<p>If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
<a href="IO/WaitReadable.html">IO::WaitReadable</a>. So <a
href="IO/WaitReadable.html">IO::WaitReadable</a> can be used to rescue the
exceptions for retrying read_nonblock.</p>

<p><a href="IO.html#method-i-read_nonblock">#read_nonblock</a> causes <a
href="EOFError.html">EOFError</a> on EOF.</p>

<p>On some platforms, such as Windows, non-blocking mode is not supported on
<a href="IO.html">IO</a> objects other than sockets. In such cases,
Errno::EBADF will be raised.</p>

<p>If the read byte buffer is not empty, <a
href="IO.html#method-i-read_nonblock">#read_nonblock</a> reads from the
buffer like readpartial. In this case, the read(2) system call is not
called.</p>

<p>When <a href="IO.html#method-i-read_nonblock">#read_nonblock</a> raises an
exception kind of <a href="IO/WaitReadable.html">IO::WaitReadable</a>, <a
href="IO.html#method-i-read_nonblock">#read_nonblock</a> should not be
called until io is readable for avoiding busy loop. This can be done as
follows.</p>

<pre class="ruby"><span class="ruby-comment"># emulates blocking read (readpartial).</span>
<span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">read_nonblock</span>(<span class="ruby-identifier">maxlen</span>)
<span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitReadable</span>
  <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>([<span class="ruby-identifier">io</span>])
  <span class="ruby-keyword">retry</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Although <a href="IO.html#method-i-read_nonblock">#read_nonblock</a>
doesn&#39;t raise <a href="IO/WaitWritable.html">IO::WaitWritable</a>.
OpenSSL::Buffering#read_nonblock can raise <a
href="IO/WaitWritable.html">IO::WaitWritable</a>. If <a
href="IO.html">IO</a> and SSL should be used polymorphically, <a
href="IO/WaitWritable.html">IO::WaitWritable</a> should be rescued too. See
the document of OpenSSL::Buffering#read_nonblock for sample code.</p>

<p>Note that this method is identical to readpartial except the non-blocking
flag is set.</p>

<p>By specifying a keyword argument <em>exception</em> to <code>false</code>,
you can indicate that <a
href="IO.html#method-i-read_nonblock">#read_nonblock</a> should not raise
an <a href="IO/WaitReadable.html">IO::WaitReadable</a> exception, but
return the symbol <code>:wait_readable</code> instead. At EOF, it will
return nil instead of raising <a href="EOFError.html">EOFError</a>.</p>
            

            
            <div class="method-source-code" id="read_nonblock-source">
              <pre> <!-- method.markup_code 290 -->
               <span class="ruby-comment"># File io.rb, line 62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">read_nonblock</span>(<span class="ruby-identifier">len</span>, <span class="ruby-identifier">buf</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">exception</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">__builtin_io_read_nonblock</span>(<span class="ruby-identifier">len</span>, <span class="ruby-identifier">buf</span>, <span class="ruby-identifier">exception</span>)
<span class="ruby-keyword">end</span>
            </pre> 
            </div><!-- read_nonblock-source -->
            
          </div>

          

          
        </div><!-- read_nonblock-method -->
      
        <div id="readbyte-method" class="method-detail ">
          <a name="method-i-readbyte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readbyte   &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads a byte as with <a href="IO.html#method-i-getbyte">#getbyte</a>, but
raises an <a href="EOFError.html">EOFError</a> on end of file.</p>
            

            
            <div class="method-source-code" id="readbyte-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_readbyte(VALUE io)
{
    VALUE c = rb_io_getbyte(io);

    if (NIL_P(c)) {
        rb_eof_error();
    }
    return c;
}
            </pre> 
            </div><!-- readbyte-source -->
            
          </div>

          

          
        </div><!-- readbyte-method -->
      
        <div id="readchar-method" class="method-detail ">
          <a name="method-i-readchar"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readchar   &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads a one-character string from <em>ios</em>. Raises an <a
href="EOFError.html">EOFError</a> on end of file.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readchar</span>   <span class="ruby-comment">#=&gt; &quot;h&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readchar</span>   <span class="ruby-comment">#=&gt; &quot;e&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="readchar-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_readchar(VALUE io)
{
    VALUE c = rb_io_getc(io);

    if (NIL_P(c)) {
        rb_eof_error();
    }
    return c;
}
            </pre> 
            </div><!-- readchar-source -->
            
          </div>

          

          
        </div><!-- readchar-method -->
      
        <div id="readline-method" class="method-detail ">
          <a name="method-i-readline"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readline(sep=$/ [, getline_args])     &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readline(limit [, getline_args])      &rarr; string</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readline(sep, limit [, getline_args]) &rarr; string</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads a line as with <a href="IO.html#method-i-gets">#gets</a>, but raises
an <a href="EOFError.html">EOFError</a> on end of file.</p>
            

            
            <div class="method-source-code" id="readline-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_readline(int argc, VALUE *argv, VALUE io)
{
    VALUE line = rb_io_gets_m(argc, argv, io);

    if (NIL_P(line)) {
        rb_eof_error();
    }
    return line;
}
            </pre> 
            </div><!-- readline-source -->
            
          </div>

          

          
        </div><!-- readline-method -->
      
        <div id="readlines-method" class="method-detail ">
          <a name="method-i-readlines"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readlines(sep=$/ [, getline_args])     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readlines(limit [, getline_args])      &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readlines(sep, limit [, getline_args]) &rarr; array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads all of the lines in <em>ios</em>, and returns them in an array. Lines
are separated by the optional <em>sep</em>. If <em>sep</em> is
<code>nil</code>, the rest of the stream is returned as a single record. If
the first argument is an integer, or an optional second argument is given,
the returning string would not be longer than the given value in bytes. The
stream must be opened for reading or an <a href="IOError.html">IOError</a>
will be raised.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readlines</span>[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>

<span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>, <span class="ruby-identifier">chomp</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readlines</span>[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; &quot;This is line one&quot;</span>
</pre>

<p>See <a href="IO.html#method-c-readlines">::readlines</a> for details about
getline_args.</p>
            

            
            <div class="method-source-code" id="readlines-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_readlines(int argc, VALUE *argv, VALUE io)
{
    struct getline_arg args;

    prepare_getline_args(argc, argv, &amp;args, io);
    return io_readlines(&amp;args, io);
}
            </pre> 
            </div><!-- readlines-source -->
            
          </div>

          

          
        </div><!-- readlines-method -->
      
        <div id="readpartial-method" class="method-detail ">
          <a name="method-i-readpartial"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">readpartial(maxlen)              &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">readpartial(maxlen, outbuf)      &rarr; outbuf</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads at most <em>maxlen</em> bytes from the I/O stream. It blocks only if
<em>ios</em> has no data immediately available. It doesn&#39;t block if
some data available.</p>

<p>If the optional <em>outbuf</em> argument is present, it must reference a <a
href="String.html">String</a>, which will receive the data. The
<em>outbuf</em> will contain only the received data after the method call
even if it is not empty at the beginning.</p>

<p>It raises <a href="EOFError.html">EOFError</a> on end of file.</p>

<p>readpartial is designed for streams such as pipe, socket, tty, etc. It
blocks only when no data immediately available. This means that it blocks
only when following all conditions hold.</p>
<ul><li>
<p>the byte buffer in the <a href="IO.html">IO</a> object is empty.</p>
</li><li>
<p>the content of the stream is empty.</p>
</li><li>
<p>the stream is not reached to EOF.</p>
</li></ul>

<p>When readpartial blocks, it waits data or EOF on the stream. If some data
is reached, readpartial returns with the data. If EOF is reached,
readpartial raises <a href="EOFError.html">EOFError</a>.</p>

<p>When readpartial doesn&#39;t blocks, it returns or raises immediately. If
the byte buffer is not empty, it returns the data in the buffer. Otherwise
if the stream has some content, it returns the data in the stream.
Otherwise if the stream is reached to EOF, it raises <a
href="EOFError.html">EOFError</a>.</p>

<pre class="ruby"><span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>           <span class="ruby-comment">#               buffer          pipe content</span>
<span class="ruby-identifier">w</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;abc&quot;</span>               <span class="ruby-comment">#               &quot;&quot;              &quot;abc&quot;.</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-value">4096</span>)      <span class="ruby-comment">#=&gt; &quot;abc&quot;       &quot;&quot;              &quot;&quot;</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-value">4096</span>)      <span class="ruby-comment"># blocks because buffer and pipe is empty.</span>

<span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>           <span class="ruby-comment">#               buffer          pipe content</span>
<span class="ruby-identifier">w</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;abc&quot;</span>               <span class="ruby-comment">#               &quot;&quot;              &quot;abc&quot;</span>
<span class="ruby-identifier">w</span>.<span class="ruby-identifier">close</span>                  <span class="ruby-comment">#               &quot;&quot;              &quot;abc&quot; EOF</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-value">4096</span>)      <span class="ruby-comment">#=&gt; &quot;abc&quot;       &quot;&quot;              EOF</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-value">4096</span>)      <span class="ruby-comment"># raises EOFError</span>

<span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>           <span class="ruby-comment">#               buffer          pipe content</span>
<span class="ruby-identifier">w</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;abc\ndef\n&quot;</span>        <span class="ruby-comment">#               &quot;&quot;              &quot;abc\ndef\n&quot;</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">gets</span>                   <span class="ruby-comment">#=&gt; &quot;abc\n&quot;     &quot;def\n&quot;         &quot;&quot;</span>
<span class="ruby-identifier">w</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;ghi\n&quot;</span>             <span class="ruby-comment">#               &quot;def\n&quot;         &quot;ghi\n&quot;</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-value">4096</span>)      <span class="ruby-comment">#=&gt; &quot;def\n&quot;     &quot;&quot;              &quot;ghi\n&quot;</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">readpartial</span>(<span class="ruby-value">4096</span>)      <span class="ruby-comment">#=&gt; &quot;ghi\n&quot;     &quot;&quot;              &quot;&quot;</span>
</pre>

<p>Note that readpartial behaves similar to sysread. The differences are:</p>
<ul><li>
<p>If the byte buffer is not empty, read from the byte buffer instead of
“sysread for buffered <a href="IO.html">IO</a> (IOError)”.</p>
</li><li>
<p>It doesn&#39;t cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial
meets EWOULDBLOCK and EINTR by read system call, readpartial retry the
system call.</p>
</li></ul>

<p>The latter means that readpartial is nonblocking-flag insensitive. It
blocks on the situation <a href="IO.html#method-i-sysread">#sysread</a>
causes Errno::EWOULDBLOCK as if the fd is blocking mode.</p>
            

            
            <div class="method-source-code" id="readpartial-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
io_readpartial(int argc, VALUE *argv, VALUE io)
{
    VALUE ret;

    ret = io_getpartial(argc, argv, io, Qnil, 0);
    if (NIL_P(ret))
        rb_eof_error();
    return ret;
}
            </pre> 
            </div><!-- readpartial-source -->
            
          </div>

          

          
        </div><!-- readpartial-method -->
      
        <div id="reopen-method" class="method-detail ">
          <a name="method-i-reopen"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reopen(other_IO)             &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reopen(path, mode [, opt])   &rarr; ios</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reassociates <em>ios</em> with the I/O stream given in <em>other_IO</em> or
to a new stream opened on <em>path</em>. This may dynamically change the
actual class of this stream. The <code>mode</code> and <code>opt</code>
parameters accept the same values as <a
href="IO.html#method-c-open">::open</a>.</p>

<pre class="ruby"><span class="ruby-identifier">f1</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f2</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f2</span>.<span class="ruby-identifier">readlines</span>[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-identifier">f2</span>.<span class="ruby-identifier">reopen</span>(<span class="ruby-identifier">f1</span>)     <span class="ruby-comment">#=&gt; #&lt;File:testfile&gt;</span>
<span class="ruby-identifier">f2</span>.<span class="ruby-identifier">readlines</span>[<span class="ruby-value">0</span>]   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="reopen-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_reopen(int argc, VALUE *argv, VALUE file)
{
    VALUE fname, nmode, opt;
    int oflags;
    rb_io_t *fptr;

    if (rb_scan_args(argc, argv, &quot;11:&quot;, &amp;fname, &amp;nmode, &amp;opt) == 1) {
        VALUE tmp = rb_io_check_io(fname);
        if (!NIL_P(tmp)) {
            return io_reopen(file, tmp);
        }
    }

    FilePathValue(fname);
    rb_io_taint_check(file);
    fptr = RFILE(file)-&gt;fptr;
    if (!fptr) {
        fptr = RFILE(file)-&gt;fptr = ZALLOC(rb_io_t);
    }

    if (!NIL_P(nmode) || !NIL_P(opt)) {
        int fmode;
        convconfig_t convconfig;

        rb_io_extract_modeenc(&amp;nmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);
        if (IS_PREP_STDIO(fptr) &amp;&amp;
            ((fptr-&gt;mode &amp; FMODE_READWRITE) &amp; (fmode &amp; FMODE_READWRITE)) !=
            (fptr-&gt;mode &amp; FMODE_READWRITE)) {
            rb_raise(rb_eArgError,
                     &quot;%s can&#39;t change access mode from \&quot;%s\&quot; to \&quot;%s\&quot;&quot;,
                     PREP_STDIO_NAME(fptr), rb_io_fmode_modestr(fptr-&gt;mode),
                     rb_io_fmode_modestr(fmode));
        }
        fptr-&gt;mode = fmode;
        fptr-&gt;encs = convconfig;
    }
    else {
        oflags = rb_io_fmode_oflags(fptr-&gt;mode);
    }

    fptr-&gt;pathv = fname;
    if (fptr-&gt;fd &lt; 0) {
        fptr-&gt;fd = rb_sysopen(fptr-&gt;pathv, oflags, 0666);
        fptr-&gt;stdio_file = 0;
        return file;
    }

    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        if (io_fflush(fptr) &lt; 0)
            rb_sys_fail(0);
    }
    fptr-&gt;rbuf.off = fptr-&gt;rbuf.len = 0;

    if (fptr-&gt;stdio_file) {
        int e = rb_freopen(rb_str_encode_ospath(fptr-&gt;pathv),
                           rb_io_oflags_modestr(oflags),
                           fptr-&gt;stdio_file);
        if (e) rb_syserr_fail_path(e, fptr-&gt;pathv);
        fptr-&gt;fd = fileno(fptr-&gt;stdio_file);
        rb_fd_fix_cloexec(fptr-&gt;fd);
#ifdef USE_SETVBUF
        if (setvbuf(fptr-&gt;stdio_file, NULL, _IOFBF, 0) != 0)
            rb_warn(&quot;setvbuf() can&#39;t be honoured for %&quot;PRIsVALUE, fptr-&gt;pathv);
#endif
        if (fptr-&gt;stdio_file == stderr) {
            if (setvbuf(fptr-&gt;stdio_file, NULL, _IONBF, BUFSIZ) != 0)
                rb_warn(&quot;setvbuf() can&#39;t be honoured for %&quot;PRIsVALUE, fptr-&gt;pathv);
        }
        else if (fptr-&gt;stdio_file == stdout &amp;&amp; isatty(fptr-&gt;fd)) {
            if (setvbuf(fptr-&gt;stdio_file, NULL, _IOLBF, BUFSIZ) != 0)
                rb_warn(&quot;setvbuf() can&#39;t be honoured for %&quot;PRIsVALUE, fptr-&gt;pathv);
        }
    }
    else {
        int tmpfd = rb_sysopen(fptr-&gt;pathv, oflags, 0666);
        int err = 0;
        if (rb_cloexec_dup2(tmpfd, fptr-&gt;fd) &lt; 0)
            err = errno;
        (void)close(tmpfd);
        if (err) {
            rb_syserr_fail_path(err, fptr-&gt;pathv);
        }
    }

    return file;
}
            </pre> 
            </div><!-- reopen-source -->
            
          </div>

          

          
        </div><!-- reopen-method -->
      
        <div id="rewind-method" class="method-detail ">
          <a name="method-i-rewind"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rewind    &rarr; 0</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Positions <em>ios</em> to the beginning of input, resetting <a
href="IO.html#method-i-lineno">lineno</a> to zero.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readline</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">rewind</span>     <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">lineno</span>     <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readline</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
</pre>

<p>Note that it cannot be used with streams such as pipes, ttys, and sockets.</p>
            

            
            <div class="method-source-code" id="rewind-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_rewind(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (io_seek(fptr, 0L, 0) &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    if (io == ARGF.current_file) {
        ARGF.lineno -= fptr-&gt;lineno;
    }
    fptr-&gt;lineno = 0;
    if (fptr-&gt;readconv) {
        clear_readconv(fptr);
    }

    return INT2FIX(0);
}
            </pre> 
            </div><!-- rewind-source -->
            
          </div>

          

          
        </div><!-- rewind-method -->
      
        <div id="seek-method" class="method-detail ">
          <a name="method-i-seek"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">seek(amount, whence=IO::SEEK_SET)  &rarr; 0</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Seeks to a given offset <em>anInteger</em> in the stream according to the
value of <em>whence</em>:</p>

<pre>:CUR or IO::SEEK_CUR  | Seeks to _amount_ plus current position
----------------------+--------------------------------------------------
:END or IO::SEEK_END  | Seeks to _amount_ plus end of stream (you
                      | probably want a negative value for _amount_)
----------------------+--------------------------------------------------
:SET or IO::SEEK_SET  | Seeks to the absolute location given by _amount_</pre>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">seek</span>(<span class="ruby-value">-13</span>, <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">SEEK_END</span>)   <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">readline</span>                  <span class="ruby-comment">#=&gt; &quot;And so on...\n&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="seek-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_seek_m(int argc, VALUE *argv, VALUE io)
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;offset, &amp;ptrname) == 2) {
        whence = interpret_seek_whence(ptrname);
    }

    return rb_io_seek(io, offset, whence);
}
            </pre> 
            </div><!-- seek-source -->
            
          </div>

          

          
        </div><!-- seek-method -->
      
        <div id="set_encoding-method" class="method-detail ">
          <a name="method-i-set_encoding"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding(ext_enc)                &rarr; io</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding("ext_enc:int_enc")      &rarr; io</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding(ext_enc, int_enc)       &rarr; io</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding("ext_enc:int_enc", opt) &rarr; io</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding(ext_enc, int_enc, opt)  &rarr; io</span>
            
          </div>
          
          
          <div>
  
            
            <p>If single argument is specified, read string from io is tagged with the
encoding specified.  If encoding is a colon separated two encoding names
“A:B”, the read string is converted from encoding A (external encoding) to
encoding B (internal encoding), then tagged with B.  If two arguments are
specified, those must be encoding objects or encoding names, and the first
one is the external encoding, and the second one is the internal encoding.
If the external encoding and the internal encoding is specified, optional
hash argument specify the conversion option.</p>
            

            
            <div class="method-source-code" id="set_encoding-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_set_encoding(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr;
    VALUE v1, v2, opt;

    if (!RB_TYPE_P(io, T_FILE)) {
        return rb_funcallv(io, id_set_encoding, argc, argv);
    }

    argc = rb_scan_args(argc, argv, &quot;11:&quot;, &amp;v1, &amp;v2, &amp;opt);
    GetOpenFile(io, fptr);
    io_encoding_set(fptr, v1, v2, opt);
    return io;
}
            </pre> 
            </div><!-- set_encoding-source -->
            
          </div>

          

          
        </div><!-- set_encoding-method -->
      
        <div id="set_encoding_by_bom-method" class="method-detail ">
          <a name="method-i-set_encoding_by_bom"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">set_encoding_by_bom   &rarr; encoding or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Checks if <code>ios</code> starts with a BOM, and then consumes it and sets
the external encoding.  Returns the result encoding if found, or nil.  If
<code>ios</code> is not binmode or its encoding has been set already, an
exception will be raised.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;bom.txt&quot;</span>, <span class="ruby-string">&quot;\u{FEFF}abc&quot;</span>)
<span class="ruby-identifier">ios</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;bom.txt&quot;</span>, <span class="ruby-string">&quot;rb&quot;</span>)
<span class="ruby-identifier">ios</span>.<span class="ruby-identifier">set_encoding_by_bom</span>    <span class="ruby-comment">#=&gt;  #&lt;Encoding:UTF-8&gt;</span>

<span class="ruby-constant">File</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;nobom.txt&quot;</span>, <span class="ruby-string">&quot;abc&quot;</span>)
<span class="ruby-identifier">ios</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;nobom.txt&quot;</span>, <span class="ruby-string">&quot;rb&quot;</span>)
<span class="ruby-identifier">ios</span>.<span class="ruby-identifier">set_encoding_by_bom</span>    <span class="ruby-comment">#=&gt;  nil</span>
</pre>
            

            
            <div class="method-source-code" id="set_encoding_by_bom-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_set_encoding_by_bom(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_BINMODE)) {
        rb_raise(rb_eArgError, &quot;ASCII incompatible encoding needs binmode&quot;);
    }
    if (fptr-&gt;encs.enc2) {
        rb_raise(rb_eArgError, &quot;encoding conversion is set&quot;);
    }
    else if (fptr-&gt;encs.enc &amp;&amp; fptr-&gt;encs.enc != rb_ascii8bit_encoding()) {
        rb_raise(rb_eArgError, &quot;encoding is set to %s already&quot;,
                 rb_enc_name(fptr-&gt;encs.enc));
    }
    if (!io_set_encoding_by_bom(io)) return Qnil;
    return rb_enc_from_encoding(fptr-&gt;encs.enc);
}
            </pre> 
            </div><!-- set_encoding_by_bom-source -->
            
          </div>

          

          
        </div><!-- set_encoding_by_bom-method -->
      
        <div id="stat-method" class="method-detail ">
          <a name="method-i-stat"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">stat    &rarr; stat</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns status information for <em>ios</em> as an object of type <a
href="File/Stat.html">File::Stat</a>.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">stat</span>
<span class="ruby-string">&quot;%o&quot;</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">mode</span>   <span class="ruby-comment">#=&gt; &quot;100644&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">blksize</span>       <span class="ruby-comment">#=&gt; 4096</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">atime</span>         <span class="ruby-comment">#=&gt; Wed Apr 09 08:53:54 CDT 2003</span>
</pre>
            

            
            <div class="method-source-code" id="stat-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_stat(VALUE obj)
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fptr-&gt;fd, &amp;st) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return rb_stat_new(&amp;st);
}
            </pre> 
            </div><!-- stat-source -->
            
          </div>

          

          
        </div><!-- stat-method -->
      
        <div id="sync-method" class="method-detail ">
          <a name="method-i-sync"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sync    &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current “sync mode&#39;&#39; of <em>ios</em>. When sync mode is
true, all output is immediately flushed to the underlying operating system
and is not buffered by Ruby internally. See also <a
href="IO.html#method-i-fsync">#fsync</a>.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">sync</span>   <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="sync-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_sync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    return (fptr-&gt;mode &amp; FMODE_SYNC) ? Qtrue : Qfalse;
}
            </pre> 
            </div><!-- sync-source -->
            
          </div>

          

          
        </div><!-- sync-method -->
      
        <div id="sync-3D-method" class="method-detail ">
          <a name="method-i-sync-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sync = boolean   &rarr; boolean</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the “sync mode&#39;&#39; to <code>true</code> or <code>false</code>.
When sync mode is true, all output is immediately flushed to the underlying
operating system and is not buffered internally. Returns the new state. See
also <a href="IO.html#method-i-fsync">#fsync</a>.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">sync</span> = <span class="ruby-keyword">true</span>
</pre>
            

            
            <div class="method-source-code" id="sync-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_set_sync(VALUE io, VALUE sync)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    if (RTEST(sync)) {
        fptr-&gt;mode |= FMODE_SYNC;
    }
    else {
        fptr-&gt;mode &amp;= ~FMODE_SYNC;
    }
    return sync;
}
            </pre> 
            </div><!-- sync-3D-source -->
            
          </div>

          

          
        </div><!-- sync-3D-method -->
      
        <div id="sysread-method" class="method-detail ">
          <a name="method-i-sysread"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sysread(maxlen[, outbuf])    &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reads <em>maxlen</em> bytes from <em>ios</em> using a low-level read and
returns them as a string.  Do not mix with other methods that read from
<em>ios</em> or you may get unpredictable results.</p>

<p>If the optional <em>outbuf</em> argument is present, it must reference a <a
href="String.html">String</a>, which will receive the data. The
<em>outbuf</em> will contain only the received data after the method call
even if it is not empty at the beginning.</p>

<p>Raises <a href="SystemCallError.html">SystemCallError</a> on error and <a
href="EOFError.html">EOFError</a> at end of file.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">sysread</span>(<span class="ruby-value">16</span>)   <span class="ruby-comment">#=&gt; &quot;This is line one&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="sysread-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_sysread(int argc, VALUE *argv, VALUE io)
{
    VALUE len, str;
    rb_io_t *fptr;
    long n, ilen;
    struct io_internal_read_struct iis;
    int shrinkable;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;len, &amp;str);
    ilen = NUM2LONG(len);

    shrinkable = io_setstrbuf(&amp;str, ilen);
    if (ilen == 0) return str;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);

    if (READ_DATA_BUFFERED(fptr)) {
        rb_raise(rb_eIOError, &quot;sysread for buffered IO&quot;);
    }

    /*
     * FIXME: removing rb_thread_wait_fd() here changes sysread semantics
     * on non-blocking IOs.  However, it&#39;s still currently possible
     * for sysread to raise Errno::EAGAIN if another thread read()s
     * the IO after we return from rb_thread_wait_fd() but before
     * we call read()
     */
    rb_thread_wait_fd(fptr-&gt;fd);

    rb_io_check_closed(fptr);

    io_setstrbuf(&amp;str, ilen);
    iis.fd = fptr-&gt;fd;
    iis.nonblock = 1; /* for historical reasons, maybe (see above) */
    iis.buf = RSTRING_PTR(str);
    iis.capa = ilen;
    n = read_internal_locktmp(str, &amp;iis);

    if (n &lt; 0) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    io_set_read_length(str, n, shrinkable);
    if (n == 0 &amp;&amp; ilen &gt; 0) {
        rb_eof_error();
    }

    return str;
}
            </pre> 
            </div><!-- sysread-source -->
            
          </div>

          

          
        </div><!-- sysread-method -->
      
        <div id="sysseek-method" class="method-detail ">
          <a name="method-i-sysseek"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sysseek(offset, whence=IO::SEEK_SET)   &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Seeks to a given <em>offset</em> in the stream according to the value of
<em>whence</em> (see <a href="IO.html#method-i-seek">#seek</a> for values
of <em>whence</em>). Returns the new offset into the file.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">sysseek</span>(<span class="ruby-value">-13</span>, <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">SEEK_END</span>)   <span class="ruby-comment">#=&gt; 53</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">sysread</span>(<span class="ruby-value">10</span>)                  <span class="ruby-comment">#=&gt; &quot;And so on.&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="sysseek-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_sysseek(int argc, VALUE *argv, VALUE io)
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;
    rb_io_t *fptr;
    off_t pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;offset, &amp;ptrname) == 2) {
        whence = interpret_seek_whence(ptrname);
    }
    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    if ((fptr-&gt;mode &amp; FMODE_READABLE) &amp;&amp;
        (READ_DATA_BUFFERED(fptr) || READ_CHAR_PENDING(fptr))) {
        rb_raise(rb_eIOError, &quot;sysseek for buffered IO&quot;);
    }
    if ((fptr-&gt;mode &amp; FMODE_WRITABLE) &amp;&amp; fptr-&gt;wbuf.len) {
        rb_warn(&quot;sysseek for buffered IO&quot;);
    }
    errno = 0;
    pos = lseek(fptr-&gt;fd, pos, whence);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

    return OFFT2NUM(pos);
}
            </pre> 
            </div><!-- sysseek-source -->
            
          </div>

          

          
        </div><!-- sysseek-method -->
      
        <div id="syswrite-method" class="method-detail ">
          <a name="method-i-syswrite"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">syswrite(string)   &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given string to <em>ios</em> using a low-level write. Returns
the number of bytes written. Do not mix with other methods that write to
<em>ios</em> or you may get unpredictable results. Raises <a
href="SystemCallError.html">SystemCallError</a> on error.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;out&quot;</span>, <span class="ruby-string">&quot;w&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">syswrite</span>(<span class="ruby-string">&quot;ABCDEF&quot;</span>)   <span class="ruby-comment">#=&gt; 6</span>
</pre>
            

            
            <div class="method-source-code" id="syswrite-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_syswrite(VALUE io, VALUE str)
{
    VALUE tmp;
    rb_io_t *fptr;
    long n, len;
    const char *ptr;

    if (!RB_TYPE_P(str, T_STRING))
        str = rb_obj_as_string(str);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);

    if (fptr-&gt;wbuf.len) {
        rb_warn(&quot;syswrite for buffered IO&quot;);
    }

    tmp = rb_str_tmp_frozen_acquire(str);
    RSTRING_GETMEM(tmp, ptr, len);
    n = rb_write_internal(fptr-&gt;fd, ptr, len);
    if (n &lt; 0) rb_sys_fail_path(fptr-&gt;pathv);
    rb_str_tmp_frozen_release(str, tmp);

    return LONG2FIX(n);
}
            </pre> 
            </div><!-- syswrite-source -->
            
          </div>

          

          
        </div><!-- syswrite-method -->
      
        <div id="tell-method" class="method-detail ">
          <a name="method-i-tell"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">tell    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the current offset (in bytes) of <em>ios</em>.</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">gets</span>   <span class="ruby-comment">#=&gt; &quot;This is line one\n&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">pos</span>    <span class="ruby-comment">#=&gt; 17</span>
</pre>
            

            
            <div class="method-source-code" id="tell-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_tell(VALUE io)
{
    rb_io_t *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_tell(fptr);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    pos -= fptr-&gt;rbuf.len;
    return OFFT2NUM(pos);
}
            </pre> 
            </div><!-- tell-source -->
            
          </div>

          

          
        </div><!-- tell-method -->
      
        <div id="to_i-method" class="method-detail method-alias">
          <a name="method-i-to_i"></a>

          
          <div class="method-heading">
            <span class="method-name">to_i</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="IO.html#method-i-fileno">fileno</a>
          </div>
          
        </div><!-- to_i-method -->
      
        <div id="to_io-method" class="method-detail ">
          <a name="method-i-to_io"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_io  &rarr; ios</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <em>ios</em>.</p>
            

            
            <div class="method-source-code" id="to_io-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_to_io(VALUE io)
{
    return io;
}
            </pre> 
            </div><!-- to_io-source -->
            
          </div>

          

          
        </div><!-- to_io-method -->
      
        <div id="tty-3F-method" class="method-detail ">
          <a name="method-i-tty-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">tty?     &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <em>ios</em> is associated with a terminal
device (tty), <code>false</code> otherwise.</p>

<pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>).<span class="ruby-identifier">isatty</span>   <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;/dev/tty&quot;</span>).<span class="ruby-identifier">isatty</span>   <span class="ruby-comment">#=&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="tty-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_io_isatty(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (isatty(fptr-&gt;fd) == 0)
        return Qfalse;
    return Qtrue;
}
            </pre> 
            </div><!-- tty-3F-source -->
            
          </div>

          

          
        </div><!-- tty-3F-method -->
      
        <div id="ungetbyte-method" class="method-detail ">
          <a name="method-i-ungetbyte"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ungetbyte(string)   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ungetbyte(integer)  &rarr; nil</span>
            
          </div>
          
          
          <div>
  
            
            <p>Pushes back bytes (passed as a parameter) onto <em>ios</em>, such that a
subsequent buffered read will return it. Only one byte may be pushed back
before a subsequent read operation (that is, you will be able to read only
the last of several bytes that have been pushed back). Has no effect with
unbuffered reads (such as <a href="IO.html#method-i-sysread">#sysread</a>).</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)   <span class="ruby-comment">#=&gt; #&lt;File:testfile&gt;</span>
<span class="ruby-identifier">b</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">getbyte</span>              <span class="ruby-comment">#=&gt; 0x38</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">ungetbyte</span>(<span class="ruby-identifier">b</span>)             <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">getbyte</span>                  <span class="ruby-comment">#=&gt; 0x38</span>
</pre>
            

            
            <div class="method-source-code" id="ungetbyte-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_ungetbyte(VALUE io, VALUE b)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    switch (TYPE(b)) {
      case T_NIL:
        return Qnil;
      case T_FIXNUM:
      case T_BIGNUM: ;
        VALUE v = rb_int_modulo(b, INT2FIX(256));
        unsigned char c = NUM2INT(v) &amp; 0xFF;
        b = rb_str_new((const char *)&amp;c, 1);
        break;
      default:
        SafeStringValue(b);
    }
    io_ungetbyte(b, fptr);
    return Qnil;
}
            </pre> 
            </div><!-- ungetbyte-source -->
            
          </div>

          

          
        </div><!-- ungetbyte-method -->
      
        <div id="ungetc-method" class="method-detail ">
          <a name="method-i-ungetc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ungetc(string)   &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Pushes back one character (passed as a parameter) onto <em>ios</em>, such
that a subsequent buffered character read will return it. Only one
character may be pushed back before a subsequent read operation (that is,
you will be able to read only the last of several characters that have been
pushed back). Has no effect with unbuffered reads (such as <a
href="IO.html#method-i-sysread">#sysread</a>).</p>

<pre class="ruby"><span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;testfile&quot;</span>)   <span class="ruby-comment">#=&gt; #&lt;File:testfile&gt;</span>
<span class="ruby-identifier">c</span> = <span class="ruby-identifier">f</span>.<span class="ruby-identifier">getc</span>                 <span class="ruby-comment">#=&gt; &quot;8&quot;</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">ungetc</span>(<span class="ruby-identifier">c</span>)                <span class="ruby-comment">#=&gt; nil</span>
<span class="ruby-identifier">f</span>.<span class="ruby-identifier">getc</span>                     <span class="ruby-comment">#=&gt; &quot;8&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="ungetc-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_io_ungetc(VALUE io, VALUE c)
{
    rb_io_t *fptr;
    long len;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    if (NIL_P(c)) return Qnil;
    if (FIXNUM_P(c)) {
        c = rb_enc_uint_chr(FIX2UINT(c), io_read_encoding(fptr));
    }
    else if (RB_TYPE_P(c, T_BIGNUM)) {
        c = rb_enc_uint_chr(NUM2UINT(c), io_read_encoding(fptr));
    }
    else {
        SafeStringValue(c);
    }
    if (NEED_READCONV(fptr)) {
        SET_BINARY_MODE(fptr);
        len = RSTRING_LEN(c);
#if SIZEOF_LONG &gt; SIZEOF_INT
        if (len &gt; INT_MAX)
            rb_raise(rb_eIOError, &quot;ungetc failed&quot;);
#endif
        make_readconv(fptr, (int)len);
        if (fptr-&gt;cbuf.capa - fptr-&gt;cbuf.len &lt; len)
            rb_raise(rb_eIOError, &quot;ungetc failed&quot;);
        if (fptr-&gt;cbuf.off &lt; len) {
            MEMMOVE(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.capa-fptr-&gt;cbuf.len,
                    fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,
                    char, fptr-&gt;cbuf.len);
            fptr-&gt;cbuf.off = fptr-&gt;cbuf.capa-fptr-&gt;cbuf.len;
        }
        fptr-&gt;cbuf.off -= (int)len;
        fptr-&gt;cbuf.len += (int)len;
        MEMMOVE(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, RSTRING_PTR(c), char, len);
    }
    else {
        NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);
        io_ungetbyte(c, fptr);
    }
    return Qnil;
}
            </pre> 
            </div><!-- ungetc-source -->
            
          </div>

          

          
        </div><!-- ungetc-method -->
      
        <div id="write-method" class="method-detail ">
          <a name="method-i-write"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">write(string, ...)    &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given strings to <em>ios</em>. The stream must be opened for
writing. Arguments that are not a string will be converted to a string
using <code>to_s</code>. Returns the number of bytes written in total.</p>

<pre class="ruby"><span class="ruby-identifier">count</span> = <span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;This is&quot;</span>, <span class="ruby-string">&quot; a test\n&quot;</span>)
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;That was #{count} bytes of data&quot;</span>
</pre>

<p><em>produces:</em></p>

<pre>This is a test
That was 15 bytes of data</pre>
            

            
            <div class="method-source-code" id="write-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
io_write_m(int argc, VALUE *argv, VALUE io)
{
    if (argc != 1) {
        return io_writev(argc, argv, io);
    }
    else {
        VALUE str = argv[0];
        return io_write(io, str, 0);
    }
}
            </pre> 
            </div><!-- write-source -->
            
          </div>

          

          
        </div><!-- write-method -->
      
        <div id="write_nonblock-method" class="method-detail ">
          <a name="method-i-write_nonblock"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">write_nonblock(string)   &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">write_nonblock(string [, options])   &rarr; integer</span>
            
          </div>
          
          
          <div>
  
            
            <p>Writes the given string to <em>ios</em> using the write(2) system call
after O_NONBLOCK is set for the underlying file descriptor.</p>

<p>It returns the number of bytes written.</p>

<p><a href="IO.html#method-i-write_nonblock">#write_nonblock</a> just calls
the write(2) system call. It causes all errors the write(2) system call
causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result may also be
smaller than string.length (partial write). The caller should care such
errors and partial write.</p>

<p>If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
<a href="IO/WaitWritable.html">IO::WaitWritable</a>. So <a
href="IO/WaitWritable.html">IO::WaitWritable</a> can be used to rescue the
exceptions for retrying write_nonblock.</p>

<pre class="ruby"><span class="ruby-comment"># Creates a pipe.</span>
<span class="ruby-identifier">r</span>, <span class="ruby-identifier">w</span> = <span class="ruby-constant">IO</span>.<span class="ruby-identifier">pipe</span>

<span class="ruby-comment"># write_nonblock writes only 65536 bytes and return 65536.</span>
<span class="ruby-comment"># (The pipe size is 65536 bytes on this environment.)</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;a&quot;</span> <span class="ruby-operator">*</span> <span class="ruby-value">100000</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">write_nonblock</span>(<span class="ruby-identifier">s</span>)     <span class="ruby-comment">#=&gt; 65536</span>

<span class="ruby-comment"># write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).</span>
<span class="ruby-identifier">p</span> <span class="ruby-identifier">w</span>.<span class="ruby-identifier">write_nonblock</span>(<span class="ruby-string">&quot;b&quot;</span>)   <span class="ruby-comment"># Resource temporarily unavailable (Errno::EAGAIN)</span>
</pre>

<p>If the write buffer is not empty, it is flushed at first.</p>

<p>When <a href="IO.html#method-i-write_nonblock">#write_nonblock</a> raises
an exception kind of <a href="IO/WaitWritable.html">IO::WaitWritable</a>,
<a href="IO.html#method-i-write_nonblock">#write_nonblock</a> should not be
called until io is writable for avoiding busy loop. This can be done as
follows.</p>

<pre class="ruby"><span class="ruby-keyword">begin</span>
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">write_nonblock</span>(<span class="ruby-identifier">string</span>)
<span class="ruby-keyword">rescue</span> <span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">WaitWritable</span>, <span class="ruby-constant">Errno</span><span class="ruby-operator">::</span><span class="ruby-constant">EINTR</span>
  <span class="ruby-constant">IO</span>.<span class="ruby-identifier">select</span>(<span class="ruby-keyword">nil</span>, [<span class="ruby-identifier">io</span>])
  <span class="ruby-keyword">retry</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Note that this doesn&#39;t guarantee to write all data in string. The
length written is reported as result and it should be checked later.</p>

<p>On some platforms such as Windows, <a
href="IO.html#method-i-write_nonblock">#write_nonblock</a> is not supported
according to the kind of the <a href="IO.html">IO</a> object. In such
cases, <a href="IO.html#method-i-write_nonblock">#write_nonblock</a> raises
<code>Errno::EBADF</code>.</p>

<p>By specifying a keyword argument <em>exception</em> to <code>false</code>,
you can indicate that <a
href="IO.html#method-i-write_nonblock">#write_nonblock</a> should not raise
an <a href="IO/WaitWritable.html">IO::WaitWritable</a> exception, but
return the symbol <code>:wait_writable</code> instead.</p>
            

            
            <div class="method-source-code" id="write_nonblock-source">
              <pre> <!-- method.markup_code 290 -->
               <span class="ruby-comment"># File io.rb, line 120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">write_nonblock</span>(<span class="ruby-identifier">buf</span>, <span class="ruby-identifier">exception</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">__builtin_io_write_nonblock</span>(<span class="ruby-identifier">buf</span>, <span class="ruby-identifier">exception</span>)
<span class="ruby-keyword">end</span>
            </pre> 
            </div><!-- write_nonblock-source -->
            
          </div>

          

          
        </div><!-- write_nonblock-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_IO_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_IO_versioned").load("/associated/2.7.1/IO.ihtml");</script> <div id='tx_IO' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_IO").load("/associated/IO.ihtml");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2.7.1</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>. <a href="http://neurogami.com">Maximum R+D</a>.  <div class='oio-inline'><ins data-revive-zoneid="1" data-revive-id="58924a5717c091dfee6dda3f7d38c4d7"></ins><script async src="//ras.ruby-doc.org/vvv/delivery/thesinkjs.php"></script></div></p>
 
       <p><small>Generated with Ruby-doc Rdoc Generator 0.42.0</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.ihtml");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
	} 

   //function loadInline(json){
   // for (var lookFor in json) {
    //  $(lookFor).after(json[lookFor]);
    // }
  // } // end loadInline


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2.7.1/plus_IO.ihtml', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


//     $.ajax({
//     dataType: "json",
//      url: '/associated/2.7.1/inline_IO.js',
//      success: function(json) {
// 			setTimeout(function() {
// 				loadInline(json);
// 				}, 2000);
// 			}
//    });

		});
</script>
		
</body>
</html>


